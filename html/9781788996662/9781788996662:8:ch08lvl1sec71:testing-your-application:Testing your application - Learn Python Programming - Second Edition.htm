<!DOCTYPE html>
<html class="ng-scope" lang="en" ng-app="PacktUnlimited" ng-strict-di=""><head class="ng-scope" ng-controller="metadataController as metadataController"><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><style class="vjs-styles-defaults">
      .video-js {
        width: 300px;
        height: 150px;
      }

      .vjs-fluid {
        padding-top: 56.25%
      }
    </style><style type="text/css">@charset "UTF-8";[ng\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>
<title class="ng-binding" ng-bind-html="metadataController.pageTitle">Testing your application - Learn Python Programming - Second Edition</title>
<link href="https://d3ginfw2u4xn7p.cloudfront.net/c825bf9a03a944639d91ecb1f0010fc4/images/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<meta content="CGEyu7dKgqkqBrxdainq9bY0WowOCMOdZ1nKVzzvYJg" name="google-site-verification"/>
<meta content="index,follow" name="robots"/>
<link href="https://fonts.googleapis.com/" rel="dns-prefetch"/>
<link href="https://maxcdn.bootstrapcdn.com/" rel="dns-prefetch"/>
<link href="https://cdn.polyfill.io/" rel="dns-prefetch"/>
<meta content="!" name="fragment"/>
<link href="https://subscription.packtpub.com/book/application_development/9781788996662/8/ch08lvl1sec71/testing-your-application" ng-href="https://subscription.packtpub.com/book/application_development/9781788996662/8/ch08lvl1sec71/testing-your-application" rel="canonical"/>
<meta content="There are many different kinds of tests, so many, in fact, that companies often have a dedicated department, called quality assurance (QA), made up of" name="description"/>
<meta content="#212121" name="theme-color"/>
<meta class="ng-scope" content="book" ng-if="metadataController.productType" property="og:type"/>
<meta content="Testing your application - Learn Python Programming - Second Edition" property="og:title"/>
<meta content="There are many different kinds of tests, so many, in fact, that companies often have a dedicated department, called quality assurance (QA), made up of" property="og:description"/>
<meta content="https://subscription.packtpub.com/book/application_development/9781788996662/8/ch08lvl1sec71/testing-your-application" property="og:url"/>
<meta content="https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png" property="og:image"/>
<meta content="https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png" property="og:image:secure_url"/>
<link href="https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png" ng-href="https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png" rel="image_src"/>
<meta class="ng-scope" content="Fabrizio Romano" name="book:author" ng-if="metadataController.productType &amp;&amp; metadataController.authorListString"/>
<meta class="ng-scope" content="9781788996662" name="book:isbn" ng-if="metadataController.productType &amp;&amp; metadataController.isbn"/>
<meta class="ng-scope" content="2018-06-29T06:10:00.000Z" name="book:release_date" ng-if="metadataController.productType &amp;&amp; metadataController.releaseDate"/>
<meta class="ng-scope" content="https://packtpub.com/" name="book:publisher" ng-if="metadataController.productType"/>
<meta content="Testing your application - Learn Python Programming - Second Edition" name="twitter:title"/>
<meta content="There are many different kinds of tests, so many, in fact, that companies often have a dedicated department, called quality assurance (QA), made up of" name="twitter:description"/>
<meta content="https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png" name="twitter:image"/>
<meta content="summary" name="twitter:card"/>
<meta content="@packtpub" name="twitter:site"/>
<meta content="@packtpub" name="twitter:creator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<base href="."/>
<link href="https://subscription.packtpub.com/images/apple-icons/apple-icon-57x57.png" rel="apple-touch-icon" sizes="57x57"/>
<link href="https://subscription.packtpub.com/images/apple-icons/apple-icon-72x72.png" rel="apple-touch-icon" sizes="72x72"/>
<link href="https://subscription.packtpub.com/images/apple-icons/apple-icon-114x114.png" rel="apple-touch-icon" sizes="114x114"/>
<link href="https://subscription.packtpub.com/images/apple-icons/apple-icon-144x144.png" rel="apple-touch-icon" sizes="144x144"/>
<link href="https://subscription.packtpub.com/images/apple-icons/apple-icon-180x180.png" rel="apple-touch-icon" sizes="180x180"/>
<link crossorigin="anonymous" href="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" rel="stylesheet"/>
<link href="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/css" rel="stylesheet" type="text/css"/>
<script async="" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/script.js"></script><script async="" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/f.txt" type="text/javascript"></script><script async="" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/profitwell.js"></script><script async="" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/inferredEvents.js"></script><script async="" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/445429252334850"></script><script async="" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/fbevents.js"></script><script async="" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/f.txt" type="text/javascript"></script><script async="" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/uwt.js" type="text/javascript"></script><script async="" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/analytics.js" type="text/javascript"></script><script async="" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/e8mdsr07" type="text/javascript"></script><script async="" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/heap-34805961.js" type="text/javascript"></script><script async="" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/hotjar-982604.js" type="text/javascript"></script><script async="" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/recaptcha__pl.js" type="text/javascript"></script><script async="" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/gtm.js"></script><script src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/polyfill.min.js"></script>
<script async="" defer="" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/api.js"></script>
<script async="" defer="" ng-src="https://static.zuora.com/Resources/libs/hosted/1.3.0/zuora-min.js" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/zuora-min.js"></script>
<script>
            //Set your APP_ID
            var APP_ID = 'e8mdsr07'; // to come from wpConfig

            (function(){var w=window;var ic=w.Intercom;if(typeof ic==="function"){ic('reattach_activator');ic('update',w.intercomSettings);}else{var d=document;var i=function(){i.c(arguments);};i.q=[];i.c=function(args){i.q.push(args);};w.Intercom=i;var l=function(){var s=d.createElement('script');s.type='text/javascript';s.async=true;s.src='https://widget.intercom.io/widget/' + APP_ID;var x=d.getElementsByTagName('script')[0];x.parentNode.insertBefore(s,x);};if(w.attachEvent){w.attachEvent('onload',l);}else{w.addEventListener('load',l,false);}}})();

        </script>
<script async="" charset="utf-8" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/modules.bb88fc9b50ded24ae044.js"></script><style id="mm_style_mm_cdApiStyleId_1" media="screen" type="text/css"></style><style type="text/css">iframe#_hjRemoteVarsFrame {display: none !important; width: 1px !important; height: 1px !important; opacity: 0 !important; pointer-events: none !important;}</style><script async="" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/hotjar-982604(1).js"></script><style></style><script src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/f(1).txt"></script><script src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/f(2).txt"></script><script id="schema" type="application/ld+json">{
	"@context": "https://schema.org",
	"@type": "book",
	"author": [
		"Fabrizio Romano"
	],
	"datePublished": "2018-06-29T06:10:00.000Z",
	"image": "https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png",
	"name": "Testing your application - Learn Python Programming - Second Edition",
	"publisher": {
		"@type": "Organization",
		"name": "Packt",
		"logo": {
			"@type": "ImageObject",
			"url": "https://d3ginfw2u4xn7p.cloudfront.net/c825bf9a03a944639d91ecb1f0010fc4/images/white-packt.png"
		}
	},
	"isPartOf": "/book/application_development/9781788996662",
	"description": "There are many different kinds of tests, so many, in fact, that companies often have a dedicated department, called quality assurance (QA), made up of",
	"isbn": "9781788996662",
	"bookFormat": "https://schema.org/EBook"
}</script></head><body class="prototype-nav home-body" ng-class="{
    'cover-background': currentPage === 'login' ||
        currentPage === 'create-account' ||
        currentPage === 'password-reset',
    'checkout': currentPage === 'checkout',
    'has-footer': currentPage !== 'login' &amp;&amp;
        currentPage !== 'create-account' &amp;&amp;
        currentPage !== 'password-reset' &amp;&amp;
        currentPage !== 'product',
    'has-bottom-pagination': currentPage === 'saved' ||
        currentPage === 'bookmarks' ||
        currentPage === 'purchases' ||
        currentPage === 'history',
    
    'sidebar-open': showSideBarOverlay,
    'home-body': currentPage != 'create-account' || !freeWeekend,
    'free-weekend': currentPage === 'create-account' &amp;&amp; freeWeekend,
     }"><prerender-ready class="ng-isolate-scope">
<script>
    window.prerenderReady = false;
</script>
</prerender-ready>
<script>
                window.dataLayer = window.dataLayer || [];
                (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                })(window,document,'script','dataLayer','GTM-WJMM825');
            </script>
<script src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/mmapi.js" type="text/javascript"></script><script id="" type="text/javascript">window.dataLayer=window.dataLayer||[];window.dataLayer.push({originalLocation:document.location.protocol+"//"+document.location.hostname+document.location.pathname+document.location.search});</script><script id="" type="text/javascript">Element.prototype.matches||(Element.prototype.matches=Element.prototype.matchesSelector||Element.prototype.mozMatchesSelector||Element.prototype.msMatchesSelector||Element.prototype.oMatchesSelector||Element.prototype.webkitMatchesSelector||function(a){a=(this.document||this.ownerDocument).querySelectorAll(a);for(var b=a.length;0<=--b&&a.item(b)!==this;);return-1<b});</script>
<script id="" type="text/javascript">hj("tagRecording",[google_tag_manager["GTM-WJMM825"].macro(4)]);</script><script id="mmpack.0" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/mmpackage-1.12.js" type="text/javascript"></script>

<script src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/cookieconsent.min.js" type="text/javascript"></script>

<link href="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/app.104d50d2c3a3114104d18ba8a565ba3d.bundle.css" rel="stylesheet"/>


<sidebar-overlay class="ng-isolate-scope" show="showSideBarOverlay"></sidebar-overlay>
<div class="page">
<div class="alertbox" id="alertbox"></div>
<div autoscroll="true" class="ng-scope" ng-view="" style="height:100%;">




<div class="book-page-wrapper ng-scope">
<div class="container book-page">

<div class="clearfix"></div>



<div class="container-fluid" id="book-wrapper">
<div class="ng-scope" ng-include="productController.contentView" onload="productController.onFinishLoadContent()"><div class="col-sm-12 ng-scope reader-container" id="reader-content" ng-class="{'reader-container': productController.productType === 'book'}" ng-show="productController.isContentAvailable" on-finish-page-render="productController.applyFontSize()">
<div class="row">
<div class="book-content" style="position:relative;">
<div class="ng-binding" ng-bind-html="productController.content"><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch08lvl1sec71"></a>Testing your application</h2></div></div><hr/></div><p>There are many different kinds of tests, so many, in fact, that companies often have a <span>dedicated</span><a class="indexterm" id="id326162444"></a> department, called <span class="strong"><strong>quality assurance</strong></span> (<span class="strong"><strong>QA</strong></span>), made up of <span>individuals</span><a class="indexterm" id="id326161027"></a> who spend their day testing the software the company developers produce.</p><p>To start making an initial classification, we can divide tests into two broad categories: white-box and black-box tests.</p><p><span class="strong"><strong>White-box tests</strong></span> are those that <span>exercise</span><a class="indexterm" id="id326314775"></a> the internals of the code; they inspect it down to a very fine level of detail. On the other hand, <span class="strong"><strong>black-box tests</strong></span> are those that <span>consider</span><a class="indexterm" id="id326314786"></a> the software under test as if within a box, the internals of which are ignored. Even the technology, or the language used inside the box, is not important for black-box tests. What they do is plug input into one end of the box and verify the <span>output</span><a class="indexterm" id="id326314792"></a> at the other end—that's it.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note64"></a>Note</h3><p>There is also an in-between category, called <span class="strong"><strong>gray-box</strong></span> testing, which involves testing a system in the same way we do with the black-box approach, but having some knowledge about the algorithms and data structures used to write the software and only partial access to its source code.</p></div><p>There are many different kinds of tests in these categories, each of which serves a different purpose. To give you an idea, here are a few:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Frontend tests</strong></span>: Make sure <span>that</span><a class="indexterm" id="id326346632"></a> the client side of your <span>application</span><a class="indexterm" id="id326346638"></a> is exposing the information that it should, all the links, the buttons, the advertising, everything that needs to be shown to the client. It may also verify that it is possible to walk a certain path through the user interface.</li><li style="list-style-type: disc"><span class="strong"><strong>Scenario tests</strong></span>: Make <span>use</span><a class="indexterm" id="id326346652"></a> of stories (or scenarios) that help the <span>tester</span><a class="indexterm" id="id326346659"></a> work through a complex problem or test a part of the system.
</li><li style="list-style-type: disc"><span class="strong"><strong>Integration tests</strong></span>: Verify the <span>behavior</span><a class="indexterm" id="id326346673"></a> of the various <span>components</span><a class="indexterm" id="id326346679"></a> of your application when they are working together sending messages through interfaces.</li><li style="list-style-type: disc"><span class="strong"><strong>Smoke tests</strong></span>: Particularly <span>useful</span><a class="indexterm" id="id326346762"></a> when you <span>deploy</span><a class="indexterm" id="id326346769"></a> a new update on your application. They check whether the most essential, vital parts of your application are still working as they should and that they are not <span class="emphasis"><em>on fire</em></span>. This term comes from when engineers tested circuits by making sure nothing was smoking.</li><li style="list-style-type: disc"><span class="strong"><strong>Acceptance tests</strong></span>, or <span class="strong"><strong>user acceptance testing</strong></span> (<span class="strong"><strong>UAT</strong></span>): What a <span>developer</span><a class="indexterm" id="id326346794"></a> does with a <span>product</span><a class="indexterm" id="id326346801"></a> owner (for example, in a SCRUM environment) to <span>determine</span><a class="indexterm" id="id326346807"></a> whether the work that was <span>commissioned</span><a class="indexterm" id="id326346816"></a> was carried out correctly.</li><li style="list-style-type: disc"><span class="strong"><strong>Functional tests</strong></span>: Verify the <span>features</span><a class="indexterm" id="id326383524"></a> or <span>functionalities</span><a class="indexterm" id="id326383532"></a> of your software.</li><li style="list-style-type: disc"><span class="strong"><strong>Destructive tests</strong></span>: Take down parts of your system, <span>simulating</span><a class="indexterm" id="id326383544"></a> a failure, to <span>establish</span><a class="indexterm" id="id326383550"></a> how well the remaining parts of the system perform. These kinds of tests are performed extensively by companies that need to provide an extremely reliable service, such as Amazon and Netflix, for example.</li><li style="list-style-type: disc"><span class="strong"><strong>Performance tests</strong></span>: Aim to <span>verify</span><a class="indexterm" id="id326383564"></a> how well the system <span>performs</span><a class="indexterm" id="id326383573"></a> under a specific load of data or traffic so that, for example, engineers can get a better understanding of the bottlenecks in the system that could bring it to its knees in a heavy-load situation, or those that prevent scalability.</li><li style="list-style-type: disc"><span class="strong"><strong>Usability tests</strong></span>, and the <span>closely</span><a class="indexterm" id="id326383722"></a> related <span class="strong"><strong>user experience</strong></span> (<span class="strong"><strong>UX</strong></span>) tests: Aim to check <span>whether</span><a class="indexterm" id="id326383739"></a> the user interface is simple and easy to understand and use. They aim to provide input to the designers so that the user experience is improved.</li><li style="list-style-type: disc"><span class="strong"><strong>Security and penetration tests</strong></span>: Aim to verify how <span>well</span><a class="indexterm" id="id326383751"></a> the system is <span>protected</span><a class="indexterm" id="id326383757"></a> against attacks and intrusions.</li><li style="list-style-type: disc"><span class="strong"><strong>Unit tests</strong></span>: Help the <span>developer</span><a class="indexterm" id="id326383771"></a> to write the code in a robust and <span>consistent</span><a class="indexterm" id="id326383780"></a> way, providing the first line of feedback and defense against coding mistakes, refactoring mistakes, and so on.</li><li style="list-style-type: disc"><span class="strong"><strong>Regression tests</strong></span>: Provide the <span>developer</span><a class="indexterm" id="id326421923"></a> with useful <span>information</span><a class="indexterm" id="id326421929"></a> about a feature being compromised in the system after an update. Some of the causes for a system being said to have a regression are an old bug coming back to life, an existing feature being compromised, or a new issue being introduced.</li></ul></div><p>Many books and articles have been written about testing, and I have to point you to those resources if you're interested in finding out more about all the different kinds of tests. In this chapter, we will concentrate on unit tests, since they are the backbone of software-crafting and form the vast majority of tests that are written by a developer.</p><p>Testing is an <span class="emphasis"><em>art</em></span>, an art that you don't learn from books, I'm afraid. You can learn all the definitions (and you should), and try to collect as much knowledge about testing as you can, but you will likely be able to test your software properly only when you have done it for long enough in the field.</p><p>When you are having trouble refactoring a bit of code, because every little thing you touch makes a test blow up, you learn how to write less rigid and limiting tests, which still verify the correctness of your code but, at the same time, allow you the freedom and joy to play with it, to shape it as you want.</p><p>When you are being called too often to fix unexpected bugs in your code, you learn how to write tests more thoroughly, how to come up with a more comprehensive list of edge cases, and strategies to cope with them before they turn into bugs.</p><p>When you are spending too much time reading tests and trying to refactor them to change a small feature in the code, you learn to write simpler, shorter, and better-focused tests.</p><p>I could go on with this <span class="emphasis"><em>when you... you learn...</em></span>, but I guess you get the picture. You need to get your hands dirty and build experience. My suggestion? Study the theory as much as you can, and then experiment using different approaches. Also, try to learn from experienced coders; it's very effective.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec103"></a>The anatomy of a test</h3></div></div></div><p>Before we concentrate on unit tests, let's see what a <span>test</span><a class="indexterm" id="id326421963"></a> is, and what its purpose is.</p><p>A <span class="strong"><strong>test</strong></span> is a piece of code whose purpose is to verify something in our system. It may be that we're calling a function passing two integers, that an object has a property called <code class="literal">donald_duck</code>, or that when you place an order on some API, after a minute you can see it dissected into its basic elements, in the database.</p><p>A test is typically composed of three sections:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Preparation</strong></span>: This is where you set <span>up</span><a class="indexterm" id="id326422027"></a> the scene. You prepare all the data, the objects, and the services you need in the places you need them so that they are ready to be used.</li><li style="list-style-type: disc"><span class="strong"><strong>Execution</strong></span>: This is where you execute the bit of logic that you're checking against. You perform an action using the data and the interfaces you have set <span>up</span><a class="indexterm" id="id326422041"></a> in the preparation phase.
</li><li style="list-style-type: disc"><span class="strong"><strong>Verification</strong></span>: This is where you verify the <span>results</span><a class="indexterm" id="id326422055"></a> and make sure they are according to your expectations. You check the returned value of a function, or that some data is in the database, some is not, some has changed, a request has been made, something has happened, a method has been called, and so on.</li></ul></div><p>While tests usually follow this structure, in a test suite, you will typically find some other constructs that take part in the testing game:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Setup</strong></span>: This is something quite <span>commonly</span><a class="indexterm" id="id326422074"></a> found in several different tests. It's logic that can be customized to run for every test, class, module, or even for a whole session. In this phase usually developers set up connections to databases, maybe populate them with data that will be needed there for the test to make sense, and so on.</li><li style="list-style-type: disc"><span class="strong"><strong>Teardown</strong></span>: This is the opposite of the setup; the <span>teardown</span><a class="indexterm" id="id326422089"></a> phase takes place when the tests have been run. Like the setup, it can be customized to run for every test, class or module, or session. Typically in this phase, we destroy any artefacts that were created for the test suite, and clean up after ourselves.</li><li style="list-style-type: disc"><span class="strong"><strong>Fixtures</strong></span>: They are pieces of data used in the tests. By using a <span>specific</span><a class="indexterm" id="id326422103"></a> set of fixture, outcomes are predictable and therefore tests can perform verifications against them.</li></ul></div><p>In this chapter, we will use the <code class="literal">pytest</code> Python library. It is an incredibly powerful tool that makes testing much easier and provides plenty of helpers so that the test logic can focus more on the actual testing than the wiring around it. You will see, when we get to the code, that one of the characteristics of <code class="literal">pytest</code> is that fixtures, setup, and teardown often blend into one.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec104"></a>Testing guidelines</h3></div></div></div><p>Like software, tests can be good or bad, with a whole range of <span>shades</span><a class="indexterm" id="id326422126"></a> in the middle. To write good tests, here are some guidelines:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>Keep them as simple as possible</strong></span>. It's okay to violate some good coding rules, such as hardcoding values or duplicating code. Tests need, first and foremost, to be as <span class="strong"><strong>readable</strong></span> as possible and easy to understand. When tests are hard to read or understand, you can never be confident they are actually making sure your code is performing correctly.
</li><li style="list-style-type: disc"><span class="strong"><strong>Tests should verify one thing and one thing only</strong></span>. It's very important that you keep them short and contained. It's perfectly fine to write multiple tests to exercise a single object or function. Just make sure that each test has one and only one purpose.</li><li style="list-style-type: disc"><span class="strong"><strong>Tests should not make any unnecessary assumption when verifying data</strong></span>. This is tricky to understand at first, but it is important. Verifying that the result of a function call is <code class="literal">[1, 2, 3]</code> is not the same as saying the output is a list that contains the numbers <code class="literal">1</code>, <code class="literal">2</code>, and <code class="literal">3</code>. In the former, we're also assuming the ordering; in the latter, we're only assuming which items are in the list. The differences sometimes are quite subtle, but they are still very important.</li><li style="list-style-type: disc"><span class="strong"><strong>Tests should exercise the what, rather than the how</strong></span>. Tests <span>should</span><a class="indexterm" id="id326422178"></a> focus on checking <span class="emphasis"><em>what</em></span> a function is supposed to do, rather than <span class="emphasis"><em>how</em></span> it is doing it. For example, focus on the fact that it's calculating the square root of a number (the <span class="emphasis"><em>what</em></span>), instead of on the fact that it is calling <code class="literal">math.sqrt</code> to do it (the <span class="emphasis"><em>how</em></span>). Unless you're writing performance tests or you have a particular need to verify how a certain action is performed, try to avoid this type of testing and focus on the <span class="emphasis"><em>what</em></span>. Testing the <span class="emphasis"><em>how</em></span> leads to restrictive tests and makes refactoring hard. Moreover, the type of test you have to write when you concentrate on the <span class="emphasis"><em>how</em></span> is more likely to degrade the quality of your testing code base when you amend your software frequently.</li><li style="list-style-type: disc"><span class="strong"><strong>Tests should use the minimal set of fixtures needed to do the job</strong></span>. This is another crucial point. Fixtures have a tendency to grow over time. They also tend to change every now and then. If you use big amounts of fixtures and ignore redundancies in your tests, refactoring will take longer. Spotting bugs will be harder. Try to use a set of fixtures that is big enough for the test to perform correctly, but not any bigger.</li><li style="list-style-type: disc"><span class="strong"><strong>Tests should run as fast as possible</strong></span>. A good test codebase could end up being much longer than the code being tested itself. It varies according to the situation and the developer, but, whatever the length, you'll end up having hundreds, if not thousands, of tests to run, which means the faster they run, the faster you can get back to writing code. When using TDD, for example, you run tests very often, so speed is essential.</li><li style="list-style-type: disc"><span class="strong"><strong>Tests should use up the least possible amount of resources</strong></span>. The reason for this is that every developer who checks out your code <span>should</span><a class="indexterm" id="id326425710"></a> be able to run your tests, no matter how powerful their box is. It could be a skinny virtual machine or a neglected <span>Jenkins</span><a class="indexterm" id="id326425720"></a> box, your tests should run without chewing up too many resources.
</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note65"></a>Note</h3><p>A <span class="strong"><strong>Jenkins</strong></span> box is a machine that runs Jenkins, software that is capable of, among many other things, running your tests automatically. Jenkins is frequently used in companies where developers use practices such as continuous integration and extreme programming.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec105"></a>Unit testing </h3></div></div></div><p>Now that you have an idea about what <span>testing</span><a class="indexterm" id="id326425742"></a> is and why we need it, let's introduce the developer's best friend: the <span class="strong"><strong>unit test</strong></span>.</p><p>Before we proceed with the examples, allow me to share some words of caution: I'll try to give you the fundamentals about unit testing, but I don't follow any particular school of thought or methodology to the letter. Over the years, I have tried many different testing approaches, eventually coming up with my own way of doing things, which is constantly evolving. To put it as Bruce Lee would have:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"Absorb what is useful, discard what is useless and add what is specifically your own."</em></span></p></blockquote></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec22"></a>Writing a unit test</h4></div></div></div><p>Unit tests take their name after the fact that they are <span>used</span><a class="indexterm" id="id326425768"></a> to test small units of code. To explain how to write a unit test, let's take a look at a simple snippet:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="0"># data.py
def get_clean_data(source): 
    data = load_data(source) 
    cleaned_data = clean_data(data) 
    return cleaned_data </code></pre></div><p>The <code class="literal">get_clean_data</code> function is responsible for getting data from <code class="literal">source</code>, cleaning it, and returning it to the caller. How do we test this function?</p><p>One way of doing this is to call it and then make sure that <code class="literal">load_data</code> was called once with <code class="literal">source</code> as its only argument. Then we have to verify that <code class="literal">clean_data</code> was called once, with the return value of <code class="literal">load_data</code>. And, finally, we would need to make sure that the return value of <code class="literal">clean_data</code> is what is returned by the <code class="literal">get_clean_data</code> function as well.</p><p>To do this, we need to set up the source and run this code, and this may be a problem. One of the golden rules of unit testing is that <span class="emphasis"><em>anything that crosses the boundaries of your application needs to be simulated</em></span>. We don't want to talk to a real data source, and we don't want to actually run real functions if they are communicating with anything that is not contained in our application. A few examples would be a database, a search service, an external API, and a file in the filesystem.</p><p>We need these restrictions to act as a shield, so that we can always run our tests safely without the fear of destroying something in a real data source.</p><p>Another reason is that it may be quite difficult for a single developer to reproduce the whole architecture on their box. It may require the setting up of databases, APIs, services, files and folders, and so on and so forth, and this can be difficult, time-consuming, or sometimes not even possible.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note66"></a>Note</h3><p>Very simply put, an <span class="strong"><strong>application programming interface</strong></span> (<span class="strong"><strong>API</strong></span>) is a set of tools for building software applications. An API expresses a software component in terms of its operations, input and output, and underlying types. For example, if you create a software that needs to interface with a data provider service, it's very likely that you will have to go through their API in order to gain access to the data.</p></div><p>Therefore, in our unit tests, we need to simulate all those things in some way. Unit tests need to be run by any developer without the need for the whole system to be set up on their box.</p><p>A <span>different</span><a class="indexterm" id="id326429527"></a> approach, which I always favor when it's possible to do so, is to simulate entities without using fake objects, but using special-purpose test objects instead. For example, if your code talks to a database, instead of faking all the functions and methods that talk to the database and programming the fake objects so that they return what the real ones would, I'd much rather spawn a test database, set up the tables and data I need, and then patch the connection settings so that my tests are running real code, against the test database, thereby doing no harm at all. In-memory databases are excellent options for these cases.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note67"></a>Note</h3><p>One of the applications that allow you to spawn a database for testing is Django. Within the <code class="literal">django.test</code> package, you can find several tools that help you write your tests so that you won't have to simulate the dialog with a database. By writing tests this way, you will also be able to check on transactions, encodings, and all other database-related aspects of programming. Another advantage of this approach consists in the ability of checking against things that can change from one database to another.</p></div><p>Sometimes, though, it's still not possible, and we need to use fakes, so let's talk about them.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec23"></a>Mock objects and patching</h4></div></div></div><p>First of all, in Python, these fake <span>objects</span><a class="indexterm" id="id326429553"></a> are called <span class="strong"><strong>mocks</strong></span>. Up to Version 3.3, the <code class="literal">mock</code> library was a third-party library that basically every project would install via <code class="literal">pip</code> but, from Version 3.3, it has been included in the standard library under the <code class="literal">unittest</code> module, and rightfully so, given its importance and how widespread it is.</p><p>The act of replacing a real <span>object</span><a class="indexterm" id="id326429575"></a> or function (or in general, any piece of data structure) with a mock, is called <span class="strong"><strong>patching</strong></span>. The <code class="literal">mock</code> library provides the <code class="literal">patch</code> tool, which can act as a function or class decorator, and even as a context manager that you can use to mock things out. Once you have replaced everything you don't need to run with suitable mocks, you can pass to the second phase of the test and run the code you are exercising. After the execution, you will be able to check those mocks to verify that your code has worked correctly.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec24"></a>Assertions</h4></div></div></div><p>The verification phase is done through the use of assertions. An <span class="strong"><strong>assertion</strong></span> is a function (or method) that you <span>can</span><a class="indexterm" id="id326492443"></a> use to verify equality between objects, as well as other conditions. When a condition is not met, the assertion will raise an exception that will make your test fail. You can find a list of assertions in the <code class="literal">unittest</code> module documentation; however, when using <code class="literal">pytest</code>, you will typically use the generic <code class="literal">assert</code> statement, which makes things even simpler.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl2sec106"></a>Testing a CSV generator</h3></div></div></div><p>Let's now adopt a <span>practical</span><a class="indexterm" id="id326492466"></a> approach. I will show you how to test a piece of code, and we will touch on the rest of the important concepts around unit testing, within the context of this example.</p><p>We want to write an <code class="literal">export</code> function that does the following: it takes a list of dictionaries, each of which represents a user. It creates a CSV file, puts a header in it, and then proceeds to add all the users who are deemed valid according to some rules. The <code class="literal">export</code> function takes also a filename, which will be the name for the CSV in output. And, finally, it takes an indication on whether to allow an existing file with the same name to be overwritten.</p><p>As for the users, they must abide by the following: each user has at least an email, a name, and an age. There can be a fourth field representing the role, but it's optional. The user's email address needs to be valid, the name needs to be non-empty, and the age must be an integer between 18 and 65.</p><p>This is our task, so now I'm going to show you the code, and then we're going to analyze the tests I wrote for it. But, first things first, in the following code snippets, I'll be using two third-party libraries: <code class="literal">marshmallow</code> and <code class="literal">pytest</code>. They both are in the requirements of the book's source code, so make sure you have installed them with <code class="literal">pip</code>.</p><p><code class="literal">marshmallow</code> is a wonderful library that provides us with the ability to serialize and deserialize objects and, most importantly, gives us the ability to define a schema that we can use to validate a user dictionary. <code class="literal">pytest</code> is one of the best pieces of software I have ever seen. It is used everywhere now, and has replaced other tools such as <code class="literal">nose</code>, for example. It provides us with great tools to write beautiful short tests.</p><p>But let's get to the code. I called it <code class="literal">api.py</code> just because it exposes a function that we can use to do things. I'll show it to you in chunks:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="1"># api.py
import os
import csv
from copy import deepcopy

from marshmallow import Schema, fields, pre_load
from marshmallow.validate import Length, Range

class UserSchema(Schema):
    """Represent a *valid* user. """

    email = fields.Email(required=True)
    name = fields.String(required=True, validate=Length(min=1))
    age = fields.Integer(
        required=True, validate=Range(min=18, max=65)
    )
    role = fields.String()

    @pre_load(pass_many=False)
    def strip_name(self, data):
        data_copy = deepcopy(data)

        try:
            data_copy['name'] = data_copy['name'].strip()
        except (AttributeError, KeyError, TypeError):
            pass

        return data_copy

schema = UserSchema()</code></pre></div><p>This first part is where we import all the <span>modules</span><a class="indexterm" id="id326502693"></a> we need (<code class="literal">os</code> and <code class="literal">csv</code>), and some tools from <code class="literal">marshmallow</code>, and then we define the schema for the users. As you can see, we inherit from <code class="literal">marshmallow.Schema</code>, and then we set four fields. Notice we are using two <code class="literal">String</code> fields, <code class="literal">Email</code> and <code class="literal">Integer</code>. These will already provide us with some validation from <code class="literal">marshmallow</code>. Notice there is no <code class="literal">required=True</code> in the <code class="literal">role</code> field.</p><p>We need to add a couple of custom bits of code, though. We need to add <code class="literal">validate_age</code> to make sure the value is within the range we want. We raise <code class="literal">ValidationError</code> in case it's not. And <code class="literal">marshmallow</code> will kindly take care of raising an error should we pass anything but an integer.</p><p>Next, we add <code class="literal">validate_name</code>, because the fact that a <code class="literal">name</code> key in the dictionary is there doesn't guarantee that the name is actually non-empty. So we take its value, we strip all leading and trailing whitespace characters, and if the result is empty, we raise <code class="literal">ValidationError</code> again. Notice we don't need to add a custom validator for the <code class="literal">email</code> field. This is because <code class="literal">marshmallow</code> will validate it, and a valid email cannot be empty.</p><p>We then instantiate <code class="literal">schema</code>, so that we can use it to validate data. So let's write the <code class="literal">export</code> function:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="2"># api.py
def export(filename, users, overwrite=True):
    """Export a CSV file.

    Create a CSV file and fill with valid users. If `overwrite`
    is False and file already exists, raise IOError.
    """
    if not overwrite and os.path.isfile(filename):
        raise IOError(f"'{filename}' already exists.")

    valid_users = get_valid_users(users)
    write_csv(filename, valid_users)</code></pre></div><p>As you see, its internals are quite straightforward. If <code class="literal">overwrite</code> is <code class="literal">False</code> and the file already exists, we raise <code class="literal">IOError</code> with a message saying the file already exists. Otherwise, if we can proceed, we simply get the list of valid users and feed it to <code class="literal">write_csv</code>, which is responsible for actually doing the job. Let's see how all these functions are defined:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="3"># api.py
def get_valid_users(users):
    """Yield one valid user at a time from users. """
    yield from filter(is_valid, users)

def is_valid(user):
    """Return whether or not the user is valid. """
    return not schema.validate(user)</code></pre></div><p>Turns out I coded <code class="literal">get_valid_users</code> as a generator, as there is no need to <span>make</span><a class="indexterm" id="id326605065"></a> a potentially big list in order to put it in a file. We can validate and save them one by one. The heart of validation is simply a delegation to <code class="literal">schema.validate</code>, which uses validation engine by <code class="literal">marshmallow</code>. The way this works is by returning a dictionary, which is empty if validation succeeded, or else it will contain error information. We don't really care about collecting the error information for this task, so we simply ignore it, and within <code class="literal">is_valid</code> we basically return <code class="literal">True</code> if the return value from <code class="literal">schema.validate</code> is empty, and <code class="literal">False</code> otherwise.</p><p>One last piece is missing; here it is:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="4"># api.py
def write_csv(filename, users):
    """Write a CSV given a filename and a list of users.

    The users are assumed to be valid for the given CSV structure.
    """
    fieldnames = ['email', 'name', 'age', 'role']

    with open(filename, 'x', newline='') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        for user in users:
            writer.writerow(user)</code></pre></div><p>Again, the logic is straightforward. We define the header in <code class="literal">fieldnames</code>, then we open <code class="literal">filename</code> for writing, and we specify <code class="literal">newline=''</code>, which is recommended in the documentation when dealing with CSV files. When the file has been created, we get a <code class="literal">writer</code> object by using the <code class="literal">csv.DictWriter</code> class. The beauty of this tool is that it is capable of mapping the user dictionaries to the field names, so we don't need to take care of the ordering.</p><p>We write the header first, and then we loop over the users and add them one by one. Notice, this function assumes it is fed a list of valid users, and it may break if that assumption is false (with the default values, it would break if any user dictionary had extra fields).</p><p>That's the whole code you have to keep in mind. I suggest you spend a moment to go through it again. There is no need to memorize it, and the fact that I have used small helper functions with meaningful names will enable you to follow the testing along more easily.</p><p>Let's now get to the interesting part: testing our <code class="literal">export</code> function. Once again, I'll show you the code in chunks:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="5"># tests/test_api.py
import os
from unittest.mock import patch, mock_open, call
import pytest
from ..api import is_valid, export, write_csv</code></pre></div><p>Let's start from the imports: we need <code class="literal">os</code>, temporary directories (which we already saw in <a class="link" href="https://subscription.packtpub.com/book/application_development/9781788996662/7" linkend="ch07">Chapter 7</a>, <span class="emphasis"><em>Files and Data Persistence</em></span>), then <code class="literal">pytest</code>, and, finally, we use a relative import to fetch the three functions that we want to actually test: <code class="literal">is_valid</code>, <code class="literal">export</code>, and <code class="literal">write_csv</code>.</p><p>Before we can write tests, though, we need to <span>make</span><a class="indexterm" id="id326606016"></a> a few fixtures. As you will see, a <code class="literal">fixture</code> is a function that is decorated with the <code class="literal">pytest.fixture</code> decorator. In most cases, we expect <code class="literal">fixture</code> to return something, so that we can use it in a test. We have some requirements for a user dictionary, so let's write a couple of users: one with minimal requirements, and one with full requirements. Both need to be valid. Here is the code:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="6"># tests/test_api.py
@pytest.fixture
def min_user():
    """Represent a valid user with minimal data. """
    return {
        'email': 'minimal@example.com',
        'name': 'Primus Minimus',
        'age': 18,
    }

@pytest.fixture
def full_user():
    """Represent valid user with full data. """
    return {
        'email': 'full@example.com',
        'name': 'Maximus Plenus',
        'age': 65,
        'role': 'emperor',
    }</code></pre></div><p>In this example, the only difference is the presence of the <code class="literal">role</code> key, but it's enough to show you the point I hope. Notice that instead of simply declaring dictionaries at a module level, we actually have written two functions that return a dictionary, and we have decorated them with the <code class="literal">pytest.fixture</code> decorator. This is because when you declare a dictionary at module-level, which is supposed to be used in your tests, you need to make sure you copy it at the beginning of every test. If you don't, you may have a test that modifies it, and this will affect all tests that follow it, compromising their integrity.</p><p>By using these fixtures, <code class="literal">pytest</code> will give us a new dictionary every test run, so we don't need to go through that pain ourselves. Notice that if a fixture returns another type, instead of dict, then that is what you will get in the test. Fixtures also are <span class="emphasis"><em>composable</em></span>, which means they can be used in one another, which is a very powerful feature of <code class="literal">pytest</code>. To show you this, let's write a fixture for a list of users, in which we <span>put</span><a class="indexterm" id="id326606058"></a> the two we already have, plus one that would fail validation because it has no age. Let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="7"># tests/test_api.py
@pytest.fixture
def users(min_user, full_user):
    """List of users, two valid and one invalid. """
    bad_user = {
        'email': 'invalid@example.com',
        'name': 'Horribilis',
    }
    return [min_user, bad_user, full_user]</code></pre></div><p>Nice. So, now we have two users that we can use individually, but also we have a list of three users. The first round of tests will be testing how we are validating a user. We will group all the tests for this task within a class. This not only helps giving related tests a namespace, a place to be, but, as we'll see later on, it allows us to declare class-level fixtures, which are defined just for the tests belonging to the class. Take a look at this code:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="8"># tests/test_api.py
class TestIsValid:
    """Test how code verifies whether a user is valid or not. """
    def test_minimal(self, min_user):
        assert is_valid(min_user)

    def test_full(self, full_user):
        assert is_valid(full_user)</code></pre></div><p>We start very simply by making sure our fixtures are actually passing validation. This is very important, as those fixtures will be used everywhere, so we want them to be perfect. Next, we test the age. Two things to notice here: I will not repeat the class signature, so the code that follows is indented by four spaces and it's because these are all methods within the same class, okay? And, second, we're going to use parametrization quite heavily.</p><p>Parametrization is a technique that enables us to run the same test multiple times, but feeding different data to it. It is very useful, as it allows us to write the test only once with no repetition, and the result will be very intelligently handled by <code class="literal">pytest</code>, which will run all those tests as if they were actually separate, thus providing us with clear error messages when they fail. If you parametrize manually, you lose this feature, and believe me you won't be happy. Let's see how we test the age: </p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="9"># tests/test_api.py
    @pytest.mark.parametrize('age', range(18))
    def test_invalid_age_too_young(self, age, min_user):
        min_user['age'] = age
        assert not is_valid(min_user)</code></pre></div><p>Right, so we start by writing a test to check that validation fails when the user is too young. According to our rule, a user is too young when they are younger than 18. We check for every age between 0 and 17, by using <code class="literal">range</code>.</p><p>If you take a look at how the <span>parametrization</span><a class="indexterm" id="id326161478"></a> works, you'll see we declare the name of an object, which we then pass to the signature of the method, and then we specify which values this object will take. For each value, the test will be run once. In the case of this first test, the object's name is <code class="literal">age</code>, and the values are all those returned by <code class="literal">range(18)</code>, which means all integer numbers from <code class="literal">0</code> to <code class="literal">17</code> are included. Notice how we feed <code class="literal">age</code> to the test method, right after <code class="literal">self</code>, and then we do something else, which is also very interesting. We pass this method a fixture: <code class="literal">min_user</code>. This has the effect of activating that fixture for the test run, so that we can use it, and can refer to it from within the test. In this case, we simply change the age within the <code class="literal">min_user</code> dictionary, and then we verify that the result of <code class="literal">is_valid(min_user)</code> is <code class="literal">False</code>.</p><p>We do this last bit by asserting on the fact that <code class="literal">not False</code> is <code class="literal">True</code>. In <code class="literal">pytest</code>, this is how you check for something. You simply assert that something is truthy. If that is the case, the test has succeeded. Should it instead be the opposite, the test would fail.</p><p>Let's proceed and add all the tests needed to make validation fail on the age:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="10"># tests/test_api.py
    @pytest.mark.parametrize('age', range(66, 100))
    def test_invalid_age_too_old(self, age, min_user):
        min_user['age'] = age
        assert not is_valid(min_user)

    @pytest.mark.parametrize('age', ['NaN', 3.1415, None])
    def test_invalid_age_wrong_type(self, age, min_user):
        min_user['age'] = age
        assert not is_valid(min_user)</code></pre></div><p>So, another two tests. One takes care of the other end of the spectrum, from 66 years of age to 99. And the second one instead makes sure that age is invalid when it's not an integer number, so we pass some values, such as a string, a float, and <code class="literal">None</code>, just to make sure. Notice how the structure of the test is basically always the same, but, thanks to the parametrization, we feed very different input arguments to it.</p><p>Now that we have the age-failing all sorted out, let's add a test that actually checks the age is within the valid range:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="11"># tests/test_api.py
    @pytest.mark.parametrize('age', range(18, 66))
    def test_valid_age(self, age, min_user):
        min_user['age'] = age
        assert is_valid(min_user)</code></pre></div><p>It's as easy as that. We pass the correct range, from <code class="literal">18</code> to <code class="literal">65</code>, and remove the <code class="literal">not</code> in the assertion. Notice how all tests start with the <code class="literal">test_</code> prefix, and have a different name.</p><p>We can consider the age as being <span>taken</span><a class="indexterm" id="id326161636"></a> care of. Let's move on to write tests on mandatory fields:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="12"># tests/test_api.py
    @pytest.mark.parametrize('field', ['email', 'name', 'age'])
    def test_mandatory_fields(self, field, min_user):
        min_user.pop(field)
        assert not is_valid(min_user)

    @pytest.mark.parametrize('field', ['email', 'name', 'age'])
    def test_mandatory_fields_empty(self, field, min_user):
        min_user[field] = ''
        assert not is_valid(min_user)

</code></pre></div><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="13">    def test_name_whitespace_only(self, min_user):
        min_user['name'] = ' \n\t'
        assert not is_valid(min_user)</code></pre></div><p>The previous three tests still belong to the same class. The first one tests whether a user is invalid when one of the mandatory fields is missing. Notice that at every test run, the <code class="literal">min_user</code> fixture is restored, so we only have one missing field per test run, which is the appropriate way to check for mandatory fields. We simply pop the key out of the dictionary. This time the parametrization object takes the name <code class="literal">field</code>, and, by looking at the first test, you see all the mandatory fields in the parametrization decorator: <code class="literal">email</code>, <code class="literal">name</code>, and <code class="literal">age</code>.</p><p>In the second one, things are a little different. Instead of popping keys out, we simply set them (one at a time) to the empty string. Finally, in the third one, we check for the name to be made of whitespace only.</p><p>The previous tests take care of mandatory fields being there and being non-empty, and of the formatting around the <code class="literal">name</code> key of a user. Good. Let's now write the last two tests for this class. We want to check email validity, and type for email, name, and the role:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="14"># tests/test_api.py
    @pytest.mark.parametrize(
        'email, outcome',
        [
            ('missing_at.com', False),
            ('@missing_start.com', False),
            ('missing_end@', False),
            ('missing_dot@example', False),

            ('good.one@example.com', True),
            ('δοκιμή@παράδειγμα.δοκιμή', True),
            ('аджай@экзампл.рус', True),
        ]
    )
    def test_email(self, email, outcome, min_user):
        min_user['email'] = email
        assert is_valid(min_user) == outcome</code></pre></div><p>This time, the parametrization is slightly more complex. We define two objects (<code class="literal">email</code> and <code class="literal">outcome</code>), and then we pass a list of tuples, instead of a simple list, to the decorator. What happens is that each time the test is run, one of those tuples will be unpacked so to fill the values of <code class="literal">email</code> and <code class="literal">outcome</code>, respectively. This allows us to write one test for both valid and invalid email addresses, instead of two separate ones. We define an email address, and we specify the outcome we expect from validation. The first four are invalid email addresses, but the last three are actually valid. I have used a couple of examples with Unicode, just to make sure we're not forgetting to include our friends from all over the world in the validation.</p><p>Notice how the validation is done, asserting the result of the call needs to match the outcome we have set.</p><p>Let's now write a simple test to make sure validation fails when we feed the wrong type to the fields (again, the age has been <span>taken</span><a class="indexterm" id="id326429277"></a> care of separately before):</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="15"># tests/test_api.py
    @pytest.mark.parametrize(
        'field, value',
        [
            ('email', None),
            ('email', 3.1415),
            ('email', {}),

            ('name', None),
            ('name', 3.1415),
            ('name', {}),

            ('role', None),
            ('role', 3.1415),
            ('role', {}),
        ]
    )
    def test_invalid_types(self, field, value, min_user):
        min_user[field] = value
        assert not is_valid(min_user)</code></pre></div><p>As we did before, just for fun, we pass three different values, none of which is actually a string. This test could be expanded to include more values, but, honestly, we shouldn't need to write tests such as this one. I have included it here just to show you what's possible.</p><p>Before we move to the next test class, let me talk about something we have seen when we were checking the age.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec25"></a>Boundaries and granularity</h4></div></div></div><p>While checking for the age, we have written three tests to cover the three ranges: 0-17 (fail), 18-65 (success), 66-99 (fail). Why did we do this? The answer lies in the fact that we are dealing with two boundaries: 18 and 65. So our testing needs to focus on the three regions those two boundaries define: before <code class="literal">18</code>, within <code class="literal">18</code> and <code class="literal">65</code>, and after <code class="literal">65</code>. How you do it is not crucial, as long as you make sure you test the boundaries correctly. This means if someone changes the validation in the schema from <code class="literal">18 &lt;= value &lt;= 65</code> to <code class="literal">18 &lt;= value &lt; 65</code> (notice the missing <code class="literal">=</code>), there must be a test that fails on the <code class="literal">65</code>.</p><p>This concept is known as <span class="strong"><strong>boundary</strong></span>, and it's very important that you <span>recognize</span><a class="indexterm" id="id326492549"></a> them in your code so that you can test against them.</p><p>Another important thing is to understand is which zoom level we want to get close to the boundaries. In other words, which unit should I use to move around it? In the case of age, we're dealing with integers, so a unit of <code class="literal">1</code> will be the perfect choice (which is why we used <code class="literal">16</code>, <code class="literal">17</code>, <code class="literal">18</code>, <code class="literal">19</code>, <code class="literal">20</code>, ...). But what if you were testing for a timestamp? Well, in that case, the correct granularity will likely be different. If the code has to act differently according to your timestamp and that timestamp represent seconds, then the granularity of your tests should zoom down to seconds. If the timestamp represents years, then years should be the unit you use. I hope you get the picture. This concept is known as <span class="strong"><strong>granularity</strong></span>, and needs to be combined <span>with</span><a class="indexterm" id="id326583206"></a> that of boundaries, so that by going around the boundaries with the correct granularity, you can make sure your tests are not leaving anything to chance.</p><p>Let's now continue with our example, and test the <code class="literal">export</code> function.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec26"></a>Testing the export function</h4></div></div></div><p>In the same test module, I have defined another class that <span>represents</span><a class="indexterm" id="id326583224"></a> a test suite for the <code class="literal">export</code> function. Here it is:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="16"># tests/test_api.py
class TestExport:

    @pytest.fixture
    def csv_file(self, tmpdir):
        yield tmpdir.join("out.csv")

    @pytest.fixture
    def existing_file(self, tmpdir):
        existing = tmpdir.join('existing.csv')
        existing.write('Please leave me alone...')
        yield existing</code></pre></div><p>Let's start understanding the fixtures. We have defined them at class-level this time, which means they will be alive only for as long as the tests in the class are running. We don't need these fixtures outside of this class, so it doesn't make sense to declare them at a module level like we've done with the user ones.</p><p>So, we need two files. If you recall what I wrote at the beginning of this chapter, when it comes to interaction with databases, disks, networks, and so on, we should mock everything out. However, when possible, I prefer to use a different technique. In this case, I will employ temporary folders, which will be born within the fixture, and die within it, leaving no trace of their existence. I am much happier if I can avoid mocking. Mocking is amazing, but it can be tricky, and a source of bugs, unless it's done correctly.</p><p>Now, the first fixture, <code class="literal">csv_file</code>, defines a managed context in which we obtain a reference to a temporary folder. We can consider the logic up to and including the <code class="literal">yield</code>, as the setup phase. The fixture itself, in terms of data, is represented by the temporary filename. The file itself is not present yet. When a test runs, the fixture is created, and at the end of the test, the rest of the fixture code (the one after <code class="literal">yield</code>, if any) is executed. That part can be considered the teardown phase. In this case, it consists of exiting the context manager, which means the temporary folder is deleted (along with all its content). You can put much more in each phase of any fixture, and with experience, I'm sure you'll master the art of doing setup and teardown this way. It actually comes very naturally quite quickly.</p><p>The second fixture is very similar to the first one, but we'll use it to <span>test</span><a class="indexterm" id="id326583258"></a> that we can prevent overwriting when we call <code class="literal">export</code> with <code class="literal">overwrite=False</code>. So we create a file in the temporary folder, and we put some content into it, just to have the means to verify it hasn't been touched.</p><p>Notice how both fixtures are returning the filename with the full path information, to make sure we actually use the temporary folder in our code. Let's now see the tests:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="17"># tests/test_api.py
    def test_export(self, users, csv_file):
        export(csv_file, users)

        lines = csv_file.readlines()

        assert [
            'email,name,age,role\n',
            'minimal@example.com,Primus Minimus,18,\n',
            'full@example.com,Maximus Plenus,65,emperor\n',
        ] == lines</code></pre></div><p>This test employs the <code class="literal">users</code> and <code class="literal">csv_file</code> fixtures, and immediately calls <code class="literal">export</code> with them. We expect that a file has been created, and populated with the two valid users we have (remember the list contains three users, but one is invalid).</p><p>To verify that, we open the temporary file, and collect all its lines into a list. We then compare the content of the file with a list of the lines that we expect to be in it. Notice we only put the header, and the two valid users, in the correct order.</p><p>Now we need another test, to make sure that if there is a comma in one of the values, our CSV is still generated correctly. Being a <span class="strong"><strong>comma-separated values</strong></span> (<span class="strong"><strong>CSV</strong></span>) file, we need to make sure that a comma in the data doesn't break things up:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="18"># tests/test_api.py
    def test_export_quoting(self, min_user, csv_file):
        min_user['name'] = 'A name, with a comma'

        export(csv_file, [min_user])

        lines = csv_file.readlines()
        assert [
            'email,name,age,role\n',
            'minimal@example.com,"A name, with a comma",18,\n',
        ] == lines</code></pre></div><p>This time, we don't need the whole users list, we just need one as we're testing a specific thing, and we have the previous test to make sure we're generating the file correctly with all the users. Remember, always try to minimize the work you do within a test.</p><p>So, we use <code class="literal">min_user</code>, and put a nice comma in its name. We then repeat the procedure, which is very similar to that of the previous test, and finally we make sure that the name is put in the CSV file surrounded by double quotes. This is enough for any good CSV parser to understand that they don't have to break on the comma inside the double quotes.</p><p>Now I want one more test, which needs to check that whether the file exists and we don't want to override it, our code won't touch it:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="19"># tests/test_api.py
    def test_does_not_overwrite(self, users, existing_file):
        with pytest.raises(IOError) as err:
            export(existing_file, users, overwrite=False)

        assert err.match(
            r"'{}' already exists\.".format(existing_file)
        )

        # let's also verify the file is still intact
        assert existing_file.read() == 'Please leave me alone...'</code></pre></div><p>This is a beautiful test, because it allows me to show you how you can tell <code class="literal">pytest</code> that you expect a function call to raise an exception. We do it in the context manager given to us by <code class="literal">pytest.raises</code>, to which we feed the exception we expect from the call we make inside the body of that context manager. If the exception is not raised, the test will fail.</p><p>I like to be thorough in my test, so I don't want to stop there. I also assert on the message, by using the convenient <code class="literal">err.match</code> helper (watch out, it takes a regular expression, not a simple string–we'll see regular expressions in <a class="link" href="https://subscription.packtpub.com/book/application_development/9781788996662/14" linkend="ch14">Chapter 14</a>, <span class="emphasis"><em>Web Development</em></span>).</p><p>Finally, let's make sure that the file still contains its original content (which is why I created the <code class="literal">existing_file</code> fixture) by opening it, and comparing all of its content to the string it should be.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl3sec27"></a>Final considerations</h4></div></div></div><p>Before we move on to the next topic, let me just wrap up with some considerations.</p><p>First, I hope you have noticed that I haven't tested all the functions I wrote. Specifically, I didn't test <code class="literal">get_valid_users</code>, <code class="literal">validate</code>, and <code class="literal">write_csv</code>. The reason is because these functions are implicitly tested by our test suite. We have tested <code class="literal">is_valid</code> and <code class="literal">export</code>, which is more than enough to make sure our schema is validating users correctly, and the <code class="literal">export</code> function is dealing with filtering out invalid users correctly, respecting existing files when needed, and writing a proper CSV. The functions we haven't tested are the internals, they provide logic that participates to doing something that we have thoroughly tested anyway. Would adding extra tests for those functions be good or bad? Think about it for a moment.</p><p>The answer is actually difficult. The more you test, the less you can refactor that code. As it is now, I could easily decide to call <code class="literal">is_valid</code> with another name, and I wouldn't have to change any of my tests. If you think about it, it makes sense, because as long as <code class="literal">is_valid</code> provides correct validation to the <code class="literal">get_valid_users</code> function, I don't really need to know about it. Does this make sense to you?</p><p>If instead I had tests for the <code class="literal">is_valid</code> function, then I would have to change them, if I decided to call it differently (or to somehow change its signature).</p><p>So, what is the right thing to do? Tests or no tests? It will be up to you. You have to find the right balance. My personal take on this matter is that everything needs to be thoroughly tested, either directly or indirectly. And I want the smallest possible test suite that guarantees me that. This way, I will have a great test suite in terms of coverage, but not any bigger than necessary. You need to maintain those tests!</p><p>I hope this example made sense to you, I think it has allowed me to touch on the important topics.</p><p>If you check out the source code for the book, in the <code class="literal">test_api.py</code> module, I have added a couple of extra test classes, which will show you how different testing would have been had I decided to go all the way with the mocks. Make sure you read that code and understand it well. It is quite straightforward and will offer you a good comparison with my personal approach, which I have shown you here.</p><p>Now, how about we run those tests? (The output is re-arranged to fit this book's format):</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="20"><span class="strong"><strong>$ pytest tests</strong></span>
<span class="strong"><strong>====================== test session starts ======================</strong></span>
<span class="strong"><strong>platform darwin -- Python 3.7.0b2, pytest-3.5.0, py-1.5.3, ...</strong></span>
<span class="strong"><strong>rootdir: /Users/fab/srv/lpp/ch8, inifile:</strong></span>
<span class="strong"><strong>collected 132 items</strong></span>

<span class="strong"><strong>tests/test_api.py ...............................................</strong></span>
<span class="strong"><strong>.................................................................</strong></span>
<span class="strong"><strong>.................... [100%]</strong></span>

<span class="strong"><strong>================== 132 passed in 0.41 seconds ===================</strong></span></code></pre></div><p>Make sure you run <code class="literal">$ pytest test</code> from within the <code class="literal">ch8</code> folder (add the <code class="literal">-vv</code> flag for a verbose output that will show you how parametrization modifies the names of your tests). As you can see, <code class="literal">132</code> tests were run in less than half a second, and they all succeeded. I strongly suggest you check out this code and play with it. Change something in the code and see whether any test is breaking. Understand why it is breaking. Is it something important that means the test isn't good enough? Or is it something silly that shouldn't cause the test to break? All these apparently innocuous questions will help you gain deep insight into the art of testing.</p><p>I also suggest you study the <code class="literal">unittest</code> module, and <code class="literal">pytest</code> too. These are tools you will use all the time, so you need to be very familiar with them.</p><p>Let's now check out test-driven development!</p></div></div></div></div>
<div class="ng-hide" ng-show="!productController.entitled &amp;&amp; productController.isTruncatedContent">
<div class="fade-out" ng-show="productController.productType === 'book'">
</div>
</div>
<div class="ng-hide" ng-show="!productController.entitled &amp;&amp; productController.productType === 'video'">

</div>
</div>
<div class="video-wrapper ng-hide" ng-show="productController.productType === 'video' &amp;&amp; productController.entitled">

<div class="transcript panel panel-default ng-hide" id="transcript" ng-show="productController.hasCaptions"></div>
</div>


</div>






<div class="row ns">
<hr/>
</div>
</div>

</div>
</div>
</div>
</div>
</div>
</div>


<script src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/app.dfc913a7d3f9c785692c.bundle.js" type="text/javascript"></script>
<iframe id="_hjRemoteVarsFrame" name="_hjRemoteVarsFrame" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/box-90f3a29ef7448451db5af955688970d7.html" style="display: none !important; width: 1px !important; height: 1px !important; opacity: 0 !important; pointer-events: none !important;" title="_hjRemoteVarsFrame"></iframe><script id="" type="text/javascript">window.heap=window.heap||[];
heap.load=function(e,d){window.heap.appid=e;window.heap.config=d=d||{};var a=d.forceSSL||"https:"===document.location.protocol,b=document.createElement("script");b.type="text/javascript";b.async=!0;b.src=(a?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(b,a);b=function(a){return function(){heap.push([a].concat(Array.prototype.slice.call(arguments,0)))}};a="addEventProperties addUserProperties clearEventProperties identify removeEventProperty setEventProperties track unsetEventProperty".split(" ");for(var c=
0;c<a.length;c++)heap[a[c]]=b(a[c])};window.heap.appid||heap.load("34805961");</script><script id="" type="text/javascript">var HeapUserId="undefined";"string"===typeof HeapUserId&&"undefined"!==HeapUserId&&window.heap.identify(HeapUserId);</script>
<script id="" type="text/javascript">!function(b,e,f,g,a,c,d){b.fbq||(a=b.fbq=function(){a.callMethod?a.callMethod.apply(a,arguments):a.queue.push(arguments)},b._fbq||(b._fbq=a),a.push=a,a.loaded=!0,a.version="2.0",a.queue=[],c=e.createElement(f),c.async=!0,c.src=g,d=e.getElementsByTagName(f)[0],d.parentNode.insertBefore(c,d))}(window,document,"script","//connect.facebook.net/en_US/fbevents.js");fbq("init","445429252334850");fbq("track","PageView");</script>

<script id="" type="text/javascript">window.dataLayer=window.dataLayer||[];window.dataLayer.push({pageLoaded:"pageLoaded"});</script><script id="" type="text/javascript">(function(a,e,f,g,b,c,d){a.ProfitWellObject=b;a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)};a[b].l=1*new Date;c=e.createElement(f);d=e.getElementsByTagName(f)[0];c.async=1;c.src=g;d.parentNode.insertBefore(c,d)})(window,document,"script","https://dna8twue3dlxq.cloudfront.net/js/profitwell.js","profitwell");profitwell("auth_token","8c79afc46264fdacbbb5c7bfc3b4800f");profitwell("user_email","");</script><div></div><iframe aria-hidden="true" id="intercom-frame" src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/saved_resource.html" style="position: absolute !important; opacity: 0 !important; width: 1px !important; height: 1px !important; top: 0 !important; left: 0 !important; border: none !important; display: block !important; z-index: -1 !important;" tabindex="-1"></iframe><script src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/adsct" type="text/javascript"></script><div id="intercom-css-container"><style data-emotion="intercom-global"></style><style data-emotion="intercom"></style></div><script id="" type="text/javascript">window.heap=window.heap||[];
heap.load=function(e,d){window.heap.appid=e;window.heap.config=d=d||{};var a=d.forceSSL||"https:"===document.location.protocol,b=document.createElement("script");b.type="text/javascript";b.async=!0;b.src=(a?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(b,a);b=function(a){return function(){heap.push([a].concat(Array.prototype.slice.call(arguments,0)))}};a="addEventProperties addUserProperties clearEventProperties identify removeEventProperty setEventProperties track unsetEventProperty".split(" ");for(var c=
0;c<a.length;c++)heap[a[c]]=b(a[c])};window.heap.appid||heap.load("34805961");</script><script id="" type="text/javascript">var HeapUserId="72f2212e-37fa-4f9e-80a7-7aeb3cbd99b3";"string"===typeof HeapUserId&&"undefined"!==HeapUserId&&window.heap.identify(HeapUserId);</script>
<script id="" type="text/javascript">!function(b,e,f,g,a,c,d){b.fbq||(a=b.fbq=function(){a.callMethod?a.callMethod.apply(a,arguments):a.queue.push(arguments)},b._fbq||(b._fbq=a),a.push=a,a.loaded=!0,a.version="2.0",a.queue=[],c=e.createElement(f),c.async=!0,c.src=g,d=e.getElementsByTagName(f)[0],d.parentNode.insertBefore(c,d))}(window,document,"script","//connect.facebook.net/en_US/fbevents.js");fbq("init","445429252334850");fbq("track","PageView");</script>

<script id="" type="text/javascript">(function(c,d,e,f,g,a,b){c[e]=c[e]||[];a=d.createElement(f);a.async=1;a.src=g;b=d.getElementsByTagName(f)[0];b.parentNode.insertBefore(a,b)})(window,document,"_gscq","script","//widgets.getsitecontrol.com/95715/script.js");</script><script src="./9781788996662:8:ch08lvl1sec71:testing-your-application:Testing your application - Learn Python Programming - Second Edition_files/adsct" type="text/javascript"></script></body></html>