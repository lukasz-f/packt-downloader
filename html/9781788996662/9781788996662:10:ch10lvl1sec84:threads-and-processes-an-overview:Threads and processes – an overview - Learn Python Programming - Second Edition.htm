<!DOCTYPE html>
<html class="ng-scope" lang="en" ng-app="PacktUnlimited" ng-strict-di=""><head class="ng-scope" ng-controller="metadataController as metadataController"><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><style class="vjs-styles-defaults">
      .video-js {
        width: 300px;
        height: 150px;
      }

      .vjs-fluid {
        padding-top: 56.25%
      }
    </style><style type="text/css">@charset "UTF-8";[ng\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>
<title class="ng-binding" ng-bind-html="metadataController.pageTitle">Threads and processes – an overview - Learn Python Programming - Second Edition</title>
<link href="https://d3ginfw2u4xn7p.cloudfront.net/c825bf9a03a944639d91ecb1f0010fc4/images/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<meta content="CGEyu7dKgqkqBrxdainq9bY0WowOCMOdZ1nKVzzvYJg" name="google-site-verification"/>
<meta content="index,follow" name="robots"/>
<link href="https://fonts.googleapis.com/" rel="dns-prefetch"/>
<link href="https://maxcdn.bootstrapcdn.com/" rel="dns-prefetch"/>
<link href="https://cdn.polyfill.io/" rel="dns-prefetch"/>
<meta content="!" name="fragment"/>
<link href="https://subscription.packtpub.com/book/application_development/9781788996662/10/ch10lvl1sec84/threads-and-processes-an-overview" ng-href="https://subscription.packtpub.com/book/application_development/9781788996662/10/ch10lvl1sec84/threads-and-processes-an-overview" rel="canonical"/>
<meta content="A thread can be defined as a sequence of instructions that can be run by a scheduler, which is that part of the operating system that decides which chunk of" name="description"/>
<meta content="#212121" name="theme-color"/>
<meta class="ng-scope" content="book" ng-if="metadataController.productType" property="og:type"/>
<meta content="Threads and processes – an overview - Learn Python Programming - Second Edition" property="og:title"/>
<meta content="A thread can be defined as a sequence of instructions that can be run by a scheduler, which is that part of the operating system that decides which chunk of" property="og:description"/>
<meta content="https://subscription.packtpub.com/book/application_development/9781788996662/10/ch10lvl1sec84/threads-and-processes-an-overview" property="og:url"/>
<meta content="https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png" property="og:image"/>
<meta content="https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png" property="og:image:secure_url"/>
<link href="https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png" ng-href="https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png" rel="image_src"/>
<meta class="ng-scope" content="Fabrizio Romano" name="book:author" ng-if="metadataController.productType &amp;&amp; metadataController.authorListString"/>
<meta class="ng-scope" content="9781788996662" name="book:isbn" ng-if="metadataController.productType &amp;&amp; metadataController.isbn"/>
<meta class="ng-scope" content="2018-06-29T06:10:00.000Z" name="book:release_date" ng-if="metadataController.productType &amp;&amp; metadataController.releaseDate"/>
<meta class="ng-scope" content="https://packtpub.com/" name="book:publisher" ng-if="metadataController.productType"/>
<meta content="Threads and processes – an overview - Learn Python Programming - Second Edition" name="twitter:title"/>
<meta content="A thread can be defined as a sequence of instructions that can be run by a scheduler, which is that part of the operating system that decides which chunk of" name="twitter:description"/>
<meta content="https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png" name="twitter:image"/>
<meta content="summary" name="twitter:card"/>
<meta content="@packtpub" name="twitter:site"/>
<meta content="@packtpub" name="twitter:creator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<base href="."/>
<link href="https://subscription.packtpub.com/images/apple-icons/apple-icon-57x57.png" rel="apple-touch-icon" sizes="57x57"/>
<link href="https://subscription.packtpub.com/images/apple-icons/apple-icon-72x72.png" rel="apple-touch-icon" sizes="72x72"/>
<link href="https://subscription.packtpub.com/images/apple-icons/apple-icon-114x114.png" rel="apple-touch-icon" sizes="114x114"/>
<link href="https://subscription.packtpub.com/images/apple-icons/apple-icon-144x144.png" rel="apple-touch-icon" sizes="144x144"/>
<link href="https://subscription.packtpub.com/images/apple-icons/apple-icon-180x180.png" rel="apple-touch-icon" sizes="180x180"/>
<link crossorigin="anonymous" href="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" rel="stylesheet"/>
<link href="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/css" rel="stylesheet" type="text/css"/>
<script async="" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/script.js"></script><script async="" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/f.txt" type="text/javascript"></script><script async="" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/profitwell.js"></script><script async="" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/inferredEvents.js"></script><script async="" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/445429252334850"></script><script async="" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/fbevents.js"></script><script async="" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/f.txt" type="text/javascript"></script><script async="" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/uwt.js" type="text/javascript"></script><script async="" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/analytics.js" type="text/javascript"></script><script async="" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/e8mdsr07" type="text/javascript"></script><script async="" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/heap-34805961.js" type="text/javascript"></script><script async="" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/hotjar-982604.js" type="text/javascript"></script><script async="" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/recaptcha__pl.js" type="text/javascript"></script><script async="" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/gtm.js"></script><script src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/polyfill.min.js"></script>
<script async="" defer="" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/api.js"></script>
<script async="" defer="" ng-src="https://static.zuora.com/Resources/libs/hosted/1.3.0/zuora-min.js" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/zuora-min.js"></script>
<script>
            //Set your APP_ID
            var APP_ID = 'e8mdsr07'; // to come from wpConfig

            (function(){var w=window;var ic=w.Intercom;if(typeof ic==="function"){ic('reattach_activator');ic('update',w.intercomSettings);}else{var d=document;var i=function(){i.c(arguments);};i.q=[];i.c=function(args){i.q.push(args);};w.Intercom=i;var l=function(){var s=d.createElement('script');s.type='text/javascript';s.async=true;s.src='https://widget.intercom.io/widget/' + APP_ID;var x=d.getElementsByTagName('script')[0];x.parentNode.insertBefore(s,x);};if(w.attachEvent){w.attachEvent('onload',l);}else{w.addEventListener('load',l,false);}}})();

        </script>
<script async="" charset="utf-8" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/modules.bb88fc9b50ded24ae044.js"></script><style id="mm_style_mm_cdApiStyleId_1" media="screen" type="text/css"></style><style type="text/css">iframe#_hjRemoteVarsFrame {display: none !important; width: 1px !important; height: 1px !important; opacity: 0 !important; pointer-events: none !important;}</style><script async="" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/hotjar-982604(1).js"></script><style></style><script src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/f(1).txt"></script><script src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/f(2).txt"></script><script id="schema" type="application/ld+json">{
	"@context": "https://schema.org",
	"@type": "book",
	"author": [
		"Fabrizio Romano"
	],
	"datePublished": "2018-06-29T06:10:00.000Z",
	"image": "https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png",
	"name": "Threads and processes – an overview - Learn Python Programming - Second Edition",
	"publisher": {
		"@type": "Organization",
		"name": "Packt",
		"logo": {
			"@type": "ImageObject",
			"url": "https://d3ginfw2u4xn7p.cloudfront.net/c825bf9a03a944639d91ecb1f0010fc4/images/white-packt.png"
		}
	},
	"isPartOf": "/book/application_development/9781788996662",
	"description": "A thread can be defined as a sequence of instructions that can be run by a scheduler, which is that part of the operating system that decides which chunk of",
	"isbn": "9781788996662",
	"bookFormat": "https://schema.org/EBook"
}</script></head><body class="prototype-nav home-body" ng-class="{
    'cover-background': currentPage === 'login' ||
        currentPage === 'create-account' ||
        currentPage === 'password-reset',
    'checkout': currentPage === 'checkout',
    'has-footer': currentPage !== 'login' &amp;&amp;
        currentPage !== 'create-account' &amp;&amp;
        currentPage !== 'password-reset' &amp;&amp;
        currentPage !== 'product',
    'has-bottom-pagination': currentPage === 'saved' ||
        currentPage === 'bookmarks' ||
        currentPage === 'purchases' ||
        currentPage === 'history',
    
    'sidebar-open': showSideBarOverlay,
    'home-body': currentPage != 'create-account' || !freeWeekend,
    'free-weekend': currentPage === 'create-account' &amp;&amp; freeWeekend,
     }"><prerender-ready class="ng-isolate-scope">
<script>
    window.prerenderReady = false;
</script>
</prerender-ready>
<script>
                window.dataLayer = window.dataLayer || [];
                (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                })(window,document,'script','dataLayer','GTM-WJMM825');
            </script>
<script src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/mmapi.js" type="text/javascript"></script><script id="" type="text/javascript">window.dataLayer=window.dataLayer||[];window.dataLayer.push({originalLocation:document.location.protocol+"//"+document.location.hostname+document.location.pathname+document.location.search});</script><script id="" type="text/javascript">Element.prototype.matches||(Element.prototype.matches=Element.prototype.matchesSelector||Element.prototype.mozMatchesSelector||Element.prototype.msMatchesSelector||Element.prototype.oMatchesSelector||Element.prototype.webkitMatchesSelector||function(a){a=(this.document||this.ownerDocument).querySelectorAll(a);for(var b=a.length;0<=--b&&a.item(b)!==this;);return-1<b});</script>
<script id="" type="text/javascript">hj("tagRecording",[google_tag_manager["GTM-WJMM825"].macro(4)]);</script><script id="mmpack.0" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/mmpackage-1.12.js" type="text/javascript"></script>

<script src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/cookieconsent.min.js" type="text/javascript"></script>

<link href="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/app.104d50d2c3a3114104d18ba8a565ba3d.bundle.css" rel="stylesheet"/>


<sidebar-overlay class="ng-isolate-scope" show="showSideBarOverlay"></sidebar-overlay>
<div class="page">
<div class="alertbox" id="alertbox"></div>
<div autoscroll="true" class="ng-scope" ng-view="" style="height:100%;">




<div class="book-page-wrapper ng-scope">
<div class="container book-page">

<div class="clearfix"></div>



<div class="container-fluid" id="book-wrapper">
<div class="ng-scope" ng-include="productController.contentView" onload="productController.onFinishLoadContent()"><div class="col-sm-12 ng-scope reader-container" id="reader-content" ng-class="{'reader-container': productController.productType === 'book'}" ng-show="productController.isContentAvailable" on-finish-page-render="productController.applyFontSize()">
<div class="row">
<div class="book-content" style="position:relative;">
<div class="ng-binding" ng-bind-html="productController.content"><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch10lvl1sec84"></a>Threads and processes – an overview</h2></div></div><hr/></div><p>A <span class="strong"><strong>thread</strong></span> can be <span>defined</span><a class="indexterm" id="id326439890"></a> as a sequence of <span>instructions</span><a class="indexterm" id="id326439891"></a> that can be run by a scheduler, which is that part of the operating system that decides which chunk of work will receive the necessary resources to be carried out. Typically, a thread lives within a process. A process can be defined as an instance of a computer program that is being executed.</p><p>In previous chapters, we have run our own modules and scripts with commands similar to <code class="literal">$ python my_script.py</code>. What happens when a command like that is run, is that a Python process is created. Within it, a main thread of execution is spawned. The instructions in the script are what will be run within that thread.</p><p>This is just one way of working though, and Python can actually use more than one thread within the same process, and can even spawn multiple processes. Unsurprisingly, these <span>branches</span><a class="indexterm" id="id326599203"></a> of <span>computer</span><a class="indexterm" id="id326599201"></a> science are called <span class="strong"><strong>multithreading</strong></span> and <span class="strong"><strong>multiprocessing</strong></span>.</p><p>In order to understand the difference, let's take a moment to explore threads and processes in slightly more depth.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec114"></a>Quick anatomy of a thread</h3></div></div></div><p>Generally speaking, there are two <span>different</span><a class="indexterm" id="id326439704"></a> types of threads:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>User-level threads</strong></span>: Threads <span>that</span><a class="indexterm" id="id326439721"></a> we can create and manage in order to perform a task</li><li style="list-style-type: disc"><span class="strong"><strong>Kernel-level threads</strong></span>: Low-level threads <span>that</span><a class="indexterm" id="id326439738"></a> run in kernel mode and act on behalf of the operating system</li></ul></div><p>Given that Python works at the user level, we're not going to deep dive into kernel threads at this time. Instead, we will explore several examples of user-level threads in this chapter's examples.</p><p>A thread can be in any of the following states:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><span class="strong"><strong>New thread</strong></span>: A thread <span>that</span><a class="indexterm" id="id326439764"></a> hasn't started yet, and hasn't been allocated any resources.</li><li style="list-style-type: disc"><span class="strong"><strong>Runnable</strong></span>: The thread is waiting to run. It <span>has</span><a class="indexterm" id="id326439881"></a> all the resources needed to run, and as soon as the scheduler gives it the green light, it will be run.</li><li style="list-style-type: disc"><span class="strong"><strong>Running</strong></span>: A thread whose stream of <span>instructions</span><a class="indexterm" id="id326439912"></a> is being executed. From this state, it can go back to a non-running state, or die.</li><li style="list-style-type: disc"><span class="strong"><strong>Not-running</strong></span>: A thread that has <span>been</span><a class="indexterm" id="id326439927"></a> paused. This could be due to another thread taking precedence over it, or simply because the thread is waiting for a long-running IO operation to finish.</li><li style="list-style-type: disc"><span class="strong"><strong>Dead</strong></span>: A thread that has <span>died</span><a class="indexterm" id="id326471345"></a> because it has reached the natural end of its stream of execution, or it has been killed.</li></ul></div><p>Transitions between states are provoked either by our actions or by the scheduler. There is one thing to bear in mind, though; it is best not to interfere with the death of a thread.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec30"></a>Killing threads</h4></div></div></div><p>Killing threads is not <span>considered</span><a class="indexterm" id="id326471362"></a> to be good practice. Python doesn't provide the ability to kill a thread by calling a method or function, and this should be a hint that killing threads isn't something you want to be doing.</p><p>One reason is that a thread might have children—threads spawned from within the thread itself—which would be orphaned when their parent dies. Another reason could be that if the thread you're killing is holding a resource that needs to be closed properly, you might prevent that from happening and that could potentially lead to problems.</p><p>Later, we will see an <span>example</span><a class="indexterm" id="id326471374"></a> of how we can work around these issues.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec31"></a>Context-switching</h4></div></div></div><p>We have said that the <span>scheduler</span><a class="indexterm" id="id326471404"></a> can decide when a thread can run, or is paused, and so on. Any time a running thread needs to be suspended so that another can be run, the scheduler saves the state of the running thread in a way that it will be possible, at a later time, to resume execution exactly where it was paused.</p><p>This act is called <span class="strong"><strong>context-switching</strong></span>. People do <span>that</span><a class="indexterm" id="id326583241"></a> all the time too. We are doing some paperwork, and we hear <span class="emphasis"><em>bing!</em></span> on our phone. We stop the paperwork and check our phone. When we're done dealing with what was probably the umpteenth picture of a funny cat, we go back to our paperwork. We don't start the paperwork from the beginning, though; we simply continue where we had left off.</p><p>Context-switching is a marvelous ability of modern computers, but it can become troublesome if you generate too many threads. The scheduler then will try to give each of them a chance to run for a little time, and there will be a lot of time spent saving and recovering the state of the threads that are respectively paused and restarted.</p><p>In order to avoid this problem, it is quite common to limit the amount of threads (the same consideration applies to processes) that can be run at any given point in time. This is achieved by using a structure called a pool, the size of which can be decided by the programmer. In a nutshell, we create a pool and then assign tasks to its threads. When all the threads of the pool are busy, the program won't be able to spawn a new thread until one of them terminates (and goes back to the pool). Pools are also great for saving resources, in that they provide recycling features to the thread ecosystem.</p><p>When you write multithreaded code, it is useful to have information about the machine our software is going to run on. That information, coupled with some profiling (we'll learn about it in <a class="link" href="https://subscription.packtpub.com/book/application_development/9781788996662/11" linkend="ch11">Chapter 11</a>, <span class="emphasis"><em>Debugging and Troubleshootin</em></span>g), should enable us to calibrate the size of our pools correctly.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec115"></a>The Global Interpreter Lock</h3></div></div></div><p>In July 2015, I attended the EuroPython conference in Bilbao, where I gave a talk about test-driven development. The camera operator unfortunately lost the first half of it, but I've since been able to give that talk another couple of times, so you can find a complete version of it on the web. At the conference, I had <span>the</span><a class="indexterm" id="id326583273"></a> great pleasure of meeting Guido van Rossum and talking to him, and I also attended his keynote speech.</p><p>One of the topics he addressed was <span>the</span><a class="indexterm" id="id326583284"></a> infamous <span class="strong"><strong>Global Interpreter Lock</strong></span> (<span class="strong"><strong>GIL</strong></span>). The GIL is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecodes at once. This means that even though you can write multithreaded code in Python, there is only one thread running at any point in time (per process, of course).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note71"></a>Note</h3><p>In computer programming, a mutual exclusion object (mutex) is a program object that allows multiple program threads to share the same resource, such as file access, but not simultaneously.</p></div><p>This is normally seen as an undesired limitation of the language, and many developers take pride in cursing this great villain. The truth lies somewhere else though, as was beautifully explained by Raymond Hettinger in his Keynote on Concurrency, at PyBay 2017 (<a class="ulink" href="https://bit.ly/2KcijOB" target="_blank">https://bit.ly/2KcijOB</a>). About 10 minutes in, Raymond explains that it is actually quite simple to remove the GIL from Python. It takes about a day of work. The price you pay for this <span class="emphasis"><em>GIL-ectomy</em></span> though, is that you then have to apply locks yourself wherever they are needed in your code. This leads to a more expensive footprint, as multitudes of individual locks take more time to be acquired and released, and most importantly, it introduces the risk of bugs, as writing robust multithreaded code is not easy and you might end up having to write dozens or hundreds of locks.</p><p>In order to understand what a lock is, and why you might want to use it, we first need to talk about one of the perils of multithreaded programming: race conditions.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec116"></a>Race conditions and deadlocks</h3></div></div></div><p>When it comes to <span>writing</span><a class="indexterm" id="id326598615"></a> multithreaded code, you <span>need</span><a class="indexterm" id="id326598624"></a> to be aware of the dangers that come when your code is no longer executed linearly. By that, I mean that multithreaded code is exposed to the risk of being paused at any point in time by the scheduler, because it has decided to give some CPU time to another stream of instructions.</p><p>This behavior <span>exposes</span><a class="indexterm" id="id326598636"></a> you to <span>different</span><a class="indexterm" id="id326598648"></a> types of risks, the two most famous being race conditions and deadlocks. Let's talk about them briefly.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec32"></a>Race conditions</h4></div></div></div><p>A <span class="strong"><strong>race condition</strong></span> is a behavior of a system where the output of a procedure depends on the sequence or timing of other uncontrollable events. When these events don't <span>unfold</span><a class="indexterm" id="id326599112"></a> in the <span>order</span><a class="indexterm" id="id326599122"></a> intended by the programmer, a race condition becomes a bug.</p><p>It's much easier to explain this with an example.</p><p>Imagine you have two threads running. Both are performing the same task, which consists of reading a value from a location, performing an action with that value, incrementing the value by <span class="emphasis"><em>1</em></span> unit, and saving it back. Say that the action is to post that value to an API.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch10lvl4sec0"></a>Scenario A – race condition not happening</h5></div></div></div><p>Thread <span class="emphasis"><em>A</em></span> reads the value (<span class="emphasis"><em>1</em></span>), posts <span class="emphasis"><em>1</em></span> to the API, then increments it to <span class="emphasis"><em>2</em></span>, and saves it back. Right after this, the scheduler pauses Thread <span class="emphasis"><em>A</em></span>, and runs Thread <span class="emphasis"><em>B</em></span>. Thread <span class="emphasis"><em>B</em></span><span>reads</span><a class="indexterm" id="id326599165"></a> the value (now <span class="emphasis"><em>2</em></span>), posts <span class="emphasis"><em>2</em></span> to the API, increments it to <span class="emphasis"><em>3</em></span>, and saves it back.</p><p>At this point, after the operation has happened twice, the value stored is correct: <span class="emphasis"><em>1 + 2 = 3</em></span>. Moreover, the API has been called with both <span class="emphasis"><em>1</em></span> and <span class="emphasis"><em>2</em></span>, correctly.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch10lvl4sec1"></a>Scenario B – race condition happening</h5></div></div></div><p>Thread <span class="emphasis"><em>A</em></span> reads the value (<span class="emphasis"><em>1</em></span>), posts it to the API, increments it to <span class="emphasis"><em>2</em></span>, but before it can save it back, the scheduler decides to pause thread <span class="emphasis"><em>A</em></span> in favor of Thread <span class="emphasis"><em>B</em></span>.</p><p>Thread <span class="emphasis"><em>B</em></span> reads the value (still <span class="emphasis"><em>1</em></span>!), posts it to the API, increments it to <span class="emphasis"><em>2</em></span>, and saves it back. The scheduler then switches over to Thread <span class="emphasis"><em>A</em></span> again. Thread <span class="emphasis"><em>A</em></span> resumes its stream of work by simply saving the value it was holding after incrementing, which is <span class="emphasis"><em>2</em></span>.</p><p>After this scenario, even though the <span>operation</span><a class="indexterm" id="id326599977"></a> has happened twice as in Scenario <span class="emphasis"><em>A</em></span>, the value saved is <span class="emphasis"><em>2</em></span>, and the API has been called twice with <span class="emphasis"><em>1</em></span>.</p><p>In a real-life situation, with multiple threads and real code performing several operations, the overall behavior of the program explodes into a myriad of possibilities. We'll see an example of this later on, and we'll fix it using locks.</p><p>The main problem with race conditions is that they make our code non-deterministic, which is bad. There are areas in computer science where non-determinism is used to achieve things, and that's fine, but in general you want to be able to predict how your code will behave, and race conditions make it impossible to do so.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec33"></a>Locks to the rescue</h4></div></div></div><p>Locks come to the rescue when <span>dealing</span><a class="indexterm" id="id326677934"></a> with race conditions. For example, in order to fix the preceding example, all you need is a lock around the procedure. A lock is like a <span>guardian</span><a class="indexterm" id="id326677943"></a> that will allow only one thread to take hold of it (we say <span class="emphasis"><em>to acquire</em></span> a lock), and until that thread releases the lock, no other thread can acquire it. They will have to sit and wait until the lock is available again.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="ch10lvl4sec2"></a>Scenario C – using a lock</h5></div></div></div><p>Thread <span class="emphasis"><em>A</em></span> acquires the lock, reads the value (<span class="emphasis"><em>1</em></span>), posts to the API, increases to <span class="emphasis"><em>2</em></span>, and the scheduler suspends it. Thread <span class="emphasis"><em>B</em></span> is given some CPU time, so it tries to acquire the lock. But the lock hasn't been released yet by Thread <span class="emphasis"><em>A</em></span>, so Thread <span class="emphasis"><em>B</em></span> sits and waits. The scheduler might notice this, and quickly <span>decide</span><a class="indexterm" id="id325647965"></a> to switch back to Thread <span class="emphasis"><em>A</em></span>.</p><p>Thread <span class="emphasis"><em>A</em></span> saves 2, and releases the lock, making it available to all other threads.</p><p>At this point, whether the lock is acquired again by Thread <span class="emphasis"><em>A</em></span>, or by Thread <span class="emphasis"><em>B</em></span> (because the scheduler might have decided to switch again), is not important. The procedure will always be carried out correctly, since the lock makes sure that when a thread reads a value, it has to complete the procedure (ping API, increment, and save) before any other thread can read the value as well.</p><p>There are a multitude of different locks available in the standard library. I definitely encourage you to read up on them to understand all the perils you might encounter when coding multithreaded code, and how to solve them.</p><p>Let's now talk about deadlocks.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec34"></a>Deadlocks</h4></div></div></div><p>A <span class="strong"><strong>deadlock</strong></span> is a state in <span>which</span><a class="indexterm" id="id325648006"></a> each member of a group is waiting for some other member to take action, such as sending a message or, more commonly, releasing a lock, or a resource.</p><p>A simple example will help you get the picture. Imagine two little kids playing together. Find a toy that is made of two parts, and give each of them one part. Naturally, neither of them will want to give the other one their part, and they will want the other one to release the part they have. So neither of them will be able to play with the toy, as they each hold half of it, and will indefinitely wait for the other kid to release the other half.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note72"></a>Note</h3><p>Don't worry, no kids were harmed during the making of this example. It all happened in my mind.</p></div><p>Another example could be having two threads execute the same procedure again. The procedure requires acquiring two resources, <span class="emphasis"><em>A</em></span> and <span class="emphasis"><em>B</em></span>, both guarded by a separate lock. Thread <span class="emphasis"><em>1</em></span> acquires <span class="emphasis"><em>A</em></span>, and Thread <span class="emphasis"><em>2</em></span> acquires <span class="emphasis"><em>B</em></span>, and then they will wait indefinitely until the other one releases the resource it has. But that won't happen, as they both are instructed to wait and acquire the second resource in order to complete the procedure. Threads can be <span>much</span><a class="indexterm" id="id325648043"></a> more stubborn than kids.</p><p>You can solve this problem in several ways. The easiest one might be simply to apply an order to the resources acquisition, which means that the thread that gets <span class="emphasis"><em>A</em></span>, will also get all the rest: <span class="emphasis"><em>B</em></span>, <span class="emphasis"><em>C</em></span>, and so on.</p><p>Another way is to put a lock around the whole resources acquisition procedure, so that even if it might happen out of order, it will still be within the context of a lock, which means only one thread at a time can actually gather all the resources.</p><p>Let's now pause our talk on threads for a moment, and explore processes.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec117"></a>Quick anatomy of a process</h3></div></div></div><p>Processes are normally more <span>complex</span><a class="indexterm" id="id325648072"></a> than threads. In general, they contain a main thread, but can also be multithreaded if you choose. They are capable of spawning multiple sub-threads, each of which contains its own set of registers and a stack. Each process provides all the resources that the computer needs in order to execute the program.</p><p>Similarly to using multiple threads, we can design our code to take advantage of a multiprocessing design. Multiple processes are likely to run over multiple cores, therefore with multiprocessing, you can truly parallelize computation. Their memory footprints, though, are slightly heavier than those of threads, and another drawback to using multiple processes is that <span class="strong"><strong>inter-process communication</strong></span> (<span class="strong"><strong>IPC</strong></span>) tends to be <span>more</span><a class="indexterm" id="id325648092"></a> expensive than communication between threads.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec35"></a>Properties of a process</h4></div></div></div><p>A UNIX process is <span>created</span><a class="indexterm" id="id325648105"></a> by the operating system. It typically contains the following:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">A process ID, process group ID, user ID, or group ID</li><li style="list-style-type: disc">An environment and working directory</li><li style="list-style-type: disc">Program instructions</li><li style="list-style-type: disc">Registers, a stack, and a heap</li><li style="list-style-type: disc">File descriptors</li><li style="list-style-type: disc">Signal actions</li><li style="list-style-type: disc">Shared libraries</li><li style="list-style-type: disc">Inter-process communication tools (pipes, message queues, semaphores, or shared memory)</li></ul></div><p>If you are curious about processes, open up a shell and type <code class="literal">$ top</code>. This command displays and updates sorted information about the processes that are running in your system. When I run it on my machine, the first line tells me the following:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="0"><span class="strong"><strong>$ top</strong></span>
<span class="strong"><strong>Processes: 477 total, 4 running, 473 sleeping, 2234 threads</strong></span>
<span class="strong"><strong>...</strong></span></code></pre></div><p>This gives you an idea about how much work our computers are doing without us being really aware of it.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec118"></a>Multithreading or multiprocessing?</h3></div></div></div><p>Given all this information, deciding which approach is the best means having an understanding of the type of work that needs to be carried out, and knowledge about <span>the</span><a class="indexterm" id="id325673525"></a> system that will be dedicated to doing that work.</p><p>There are advantages to both approaches, so let's try to clarify the main differences.</p><p>Here are some advantages of using multithreading:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">Threads are all born within the same process. They share resources and can communicate with one another very easily. Communication between processes requires more complex structures and techniques.</li><li style="list-style-type: disc">The overhead of spawning a thread is smaller than that of a process. Moreover, their memory footprint is also smaller.
</li><li style="list-style-type: disc">Threads can be very effective at blocking IO-bound applications. For example, while one thread is blocked waiting for a network connection to give back some data, work can be easily and effectively switched to another thread.</li><li style="list-style-type: disc">Because there aren't any shared resources between processes, we need to use IPC techniques, and they require more memory than communication between threads.</li></ul></div><p>Here are some advantages of <span>using</span><a class="indexterm" id="id325673553"></a> multiprocessing:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc">We can avoid the limitations of the GIL by using processes.</li><li style="list-style-type: disc">Sub-processes that fail won't kill the main application.</li><li style="list-style-type: disc">Threads suffer from issues such as race conditions and deadlocks; while using processes the likelihood of having to deal with them is greatly reduced.</li><li style="list-style-type: disc">Context-switching of threads can become quite expensive when their amount is above a certain threshold.</li><li style="list-style-type: disc">Processes can make better use of multicore processors.</li><li style="list-style-type: disc">Processes are better than multiple threads at handling CPU-intensive tasks.</li></ul></div><p>In this chapter, I'll show you both approaches for multiple examples, so hopefully you'll gain a good understanding of the various different techniques. Let's get to the code then!</p></div></div></div>
<div class="ng-hide" ng-show="!productController.entitled &amp;&amp; productController.isTruncatedContent">
<div class="fade-out" ng-show="productController.productType === 'book'">
</div>
</div>
<div class="ng-hide" ng-show="!productController.entitled &amp;&amp; productController.productType === 'video'">

</div>
</div>
<div class="video-wrapper ng-hide" ng-show="productController.productType === 'video' &amp;&amp; productController.entitled">

<div class="transcript panel panel-default ng-hide" id="transcript" ng-show="productController.hasCaptions"></div>
</div>


</div>






<div class="row ns">
<hr/>
</div>
</div>

</div>
</div>
</div>
</div>
</div>
</div>


<script src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/app.dfc913a7d3f9c785692c.bundle.js" type="text/javascript"></script>
<iframe id="_hjRemoteVarsFrame" name="_hjRemoteVarsFrame" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/box-90f3a29ef7448451db5af955688970d7.html" style="display: none !important; width: 1px !important; height: 1px !important; opacity: 0 !important; pointer-events: none !important;" title="_hjRemoteVarsFrame"></iframe><div></div><script id="" type="text/javascript">window.heap=window.heap||[];
heap.load=function(e,d){window.heap.appid=e;window.heap.config=d=d||{};var a=d.forceSSL||"https:"===document.location.protocol,b=document.createElement("script");b.type="text/javascript";b.async=!0;b.src=(a?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(b,a);b=function(a){return function(){heap.push([a].concat(Array.prototype.slice.call(arguments,0)))}};a="addEventProperties addUserProperties clearEventProperties identify removeEventProperty setEventProperties track unsetEventProperty".split(" ");for(var c=
0;c<a.length;c++)heap[a[c]]=b(a[c])};window.heap.appid||heap.load("34805961");</script><script id="" type="text/javascript">var HeapUserId="undefined";"string"===typeof HeapUserId&&"undefined"!==HeapUserId&&window.heap.identify(HeapUserId);</script>
<script id="" type="text/javascript">!function(b,e,f,g,a,c,d){b.fbq||(a=b.fbq=function(){a.callMethod?a.callMethod.apply(a,arguments):a.queue.push(arguments)},b._fbq||(b._fbq=a),a.push=a,a.loaded=!0,a.version="2.0",a.queue=[],c=e.createElement(f),c.async=!0,c.src=g,d=e.getElementsByTagName(f)[0],d.parentNode.insertBefore(c,d))}(window,document,"script","//connect.facebook.net/en_US/fbevents.js");fbq("init","445429252334850");fbq("track","PageView");</script>

<script id="" type="text/javascript">window.dataLayer=window.dataLayer||[];window.dataLayer.push({pageLoaded:"pageLoaded"});</script><script id="" type="text/javascript">(function(a,e,f,g,b,c,d){a.ProfitWellObject=b;a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)};a[b].l=1*new Date;c=e.createElement(f);d=e.getElementsByTagName(f)[0];c.async=1;c.src=g;d.parentNode.insertBefore(c,d)})(window,document,"script","https://dna8twue3dlxq.cloudfront.net/js/profitwell.js","profitwell");profitwell("auth_token","8c79afc46264fdacbbb5c7bfc3b4800f");profitwell("user_email","");</script><iframe aria-hidden="true" id="intercom-frame" src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/saved_resource.html" style="position: absolute !important; opacity: 0 !important; width: 1px !important; height: 1px !important; top: 0 !important; left: 0 !important; border: none !important; display: block !important; z-index: -1 !important;" tabindex="-1"></iframe><script src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/adsct" type="text/javascript"></script><div id="intercom-css-container"><style data-emotion="intercom-global"></style><style data-emotion="intercom"></style></div><script id="" type="text/javascript">window.heap=window.heap||[];
heap.load=function(e,d){window.heap.appid=e;window.heap.config=d=d||{};var a=d.forceSSL||"https:"===document.location.protocol,b=document.createElement("script");b.type="text/javascript";b.async=!0;b.src=(a?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(b,a);b=function(a){return function(){heap.push([a].concat(Array.prototype.slice.call(arguments,0)))}};a="addEventProperties addUserProperties clearEventProperties identify removeEventProperty setEventProperties track unsetEventProperty".split(" ");for(var c=
0;c<a.length;c++)heap[a[c]]=b(a[c])};window.heap.appid||heap.load("34805961");</script><script id="" type="text/javascript">var HeapUserId="72f2212e-37fa-4f9e-80a7-7aeb3cbd99b3";"string"===typeof HeapUserId&&"undefined"!==HeapUserId&&window.heap.identify(HeapUserId);</script>
<script id="" type="text/javascript">!function(b,e,f,g,a,c,d){b.fbq||(a=b.fbq=function(){a.callMethod?a.callMethod.apply(a,arguments):a.queue.push(arguments)},b._fbq||(b._fbq=a),a.push=a,a.loaded=!0,a.version="2.0",a.queue=[],c=e.createElement(f),c.async=!0,c.src=g,d=e.getElementsByTagName(f)[0],d.parentNode.insertBefore(c,d))}(window,document,"script","//connect.facebook.net/en_US/fbevents.js");fbq("init","445429252334850");fbq("track","PageView");</script>

<script id="" type="text/javascript">(function(c,d,e,f,g,a,b){c[e]=c[e]||[];a=d.createElement(f);a.async=1;a.src=g;b=d.getElementsByTagName(f)[0];b.parentNode.insertBefore(a,b)})(window,document,"_gscq","script","//widgets.getsitecontrol.com/95715/script.js");</script><script src="./9781788996662:10:ch10lvl1sec84:threads-and-processes-an-overview:Threads and processes – an overview - Learn Python Programming - Second Edition_files/adsct" type="text/javascript"></script></body></html>