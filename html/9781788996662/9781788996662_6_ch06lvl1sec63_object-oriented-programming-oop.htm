<!DOCTYPE html>
<html class="ng-scope" lang="en" ng-app="PacktUnlimited" ng-strict-di=""><head class="ng-scope" ng-controller="metadataController as metadataController"><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><style class="vjs-styles-defaults">
      .video-js {
        width: 300px;
        height: 150px;
      }

      .vjs-fluid {
        padding-top: 56.25%
      }
    </style><style type="text/css">@charset "UTF-8";[ng\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>
<title class="ng-binding" ng-bind-html="metadataController.pageTitle">Object-oriented programming (OOP) - Learn Python Programming - Second Edition</title>
<link href="https://d3ginfw2u4xn7p.cloudfront.net/c825bf9a03a944639d91ecb1f0010fc4/images/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<meta content="CGEyu7dKgqkqBrxdainq9bY0WowOCMOdZ1nKVzzvYJg" name="google-site-verification"/>
<meta content="index,follow" name="robots"/>
<link href="https://fonts.googleapis.com/" rel="dns-prefetch"/>
<link href="https://maxcdn.bootstrapcdn.com/" rel="dns-prefetch"/>
<link href="https://cdn.polyfill.io/" rel="dns-prefetch"/>
<meta content="!" name="fragment"/>
<link href="https://subscription.packtpub.com/book/application_development/9781788996662/6/ch06lvl1sec63/object-oriented-programming-oop" ng-href="https://subscription.packtpub.com/book/application_development/9781788996662/6/ch06lvl1sec63/object-oriented-programming-oop" rel="canonical"/>
<meta content="It's been quite a long and hopefully nice journey and, by now, we should be ready to explore OOP. I'll use the definition from Kindler, E.; Krivy, I. (2011)." name="description"/>
<meta content="#212121" name="theme-color"/>
<meta class="ng-scope" content="book" ng-if="metadataController.productType" property="og:type"/>
<meta content="Object-oriented programming (OOP) - Learn Python Programming - Second Edition" property="og:title"/>
<meta content="It's been quite a long and hopefully nice journey and, by now, we should be ready to explore OOP. I'll use the definition from Kindler, E.; Krivy, I. (2011)." property="og:description"/>
<meta content="https://subscription.packtpub.com/book/application_development/9781788996662/6/ch06lvl1sec63/object-oriented-programming-oop" property="og:url"/>
<meta content="https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png" property="og:image"/>
<meta content="https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png" property="og:image:secure_url"/>
<link href="https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png" ng-href="https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png" rel="image_src"/>
<meta class="ng-scope" content="Fabrizio Romano" name="book:author" ng-if="metadataController.productType &amp;&amp; metadataController.authorListString"/>
<meta class="ng-scope" content="9781788996662" name="book:isbn" ng-if="metadataController.productType &amp;&amp; metadataController.isbn"/>
<meta class="ng-scope" content="2018-06-29T06:10:00.000Z" name="book:release_date" ng-if="metadataController.productType &amp;&amp; metadataController.releaseDate"/>
<meta class="ng-scope" content="https://packtpub.com/" name="book:publisher" ng-if="metadataController.productType"/>
<meta content="Object-oriented programming (OOP) - Learn Python Programming - Second Edition" name="twitter:title"/>
<meta content="It's been quite a long and hopefully nice journey and, by now, we should be ready to explore OOP. I'll use the definition from Kindler, E.; Krivy, I. (2011)." name="twitter:description"/>
<meta content="https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png" name="twitter:image"/>
<meta content="summary" name="twitter:card"/>
<meta content="@packtpub" name="twitter:site"/>
<meta content="@packtpub" name="twitter:creator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<base href="."/>
<link href="https://subscription.packtpub.com/images/apple-icons/apple-icon-57x57.png" rel="apple-touch-icon" sizes="57x57"/>
<link href="https://subscription.packtpub.com/images/apple-icons/apple-icon-72x72.png" rel="apple-touch-icon" sizes="72x72"/>
<link href="https://subscription.packtpub.com/images/apple-icons/apple-icon-114x114.png" rel="apple-touch-icon" sizes="114x114"/>
<link href="https://subscription.packtpub.com/images/apple-icons/apple-icon-144x144.png" rel="apple-touch-icon" sizes="144x144"/>
<link href="https://subscription.packtpub.com/images/apple-icons/apple-icon-180x180.png" rel="apple-touch-icon" sizes="180x180"/>
<link crossorigin="anonymous" href="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" rel="stylesheet"/>
<link href="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/css" rel="stylesheet" type="text/css"/>
<script async="" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/script.js"></script><script async="" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/f.txt" type="text/javascript"></script><script async="" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/profitwell.js"></script><script async="" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/inferredEvents.js"></script><script async="" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/445429252334850"></script><script async="" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/fbevents.js"></script><script async="" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/f.txt" type="text/javascript"></script><script async="" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/uwt.js" type="text/javascript"></script><script async="" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/analytics.js" type="text/javascript"></script><script async="" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/e8mdsr07" type="text/javascript"></script><script async="" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/heap-34805961.js" type="text/javascript"></script><script async="" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/hotjar-982604.js" type="text/javascript"></script><script async="" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/recaptcha__pl.js" type="text/javascript"></script><script async="" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/gtm.js"></script><script src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/polyfill.min.js"></script>
<script async="" defer="" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/api.js"></script>
<script async="" defer="" ng-src="https://static.zuora.com/Resources/libs/hosted/1.3.0/zuora-min.js" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/zuora-min.js"></script>
<script>
            //Set your APP_ID
            var APP_ID = 'e8mdsr07'; // to come from wpConfig

            (function(){var w=window;var ic=w.Intercom;if(typeof ic==="function"){ic('reattach_activator');ic('update',w.intercomSettings);}else{var d=document;var i=function(){i.c(arguments);};i.q=[];i.c=function(args){i.q.push(args);};w.Intercom=i;var l=function(){var s=d.createElement('script');s.type='text/javascript';s.async=true;s.src='https://widget.intercom.io/widget/' + APP_ID;var x=d.getElementsByTagName('script')[0];x.parentNode.insertBefore(s,x);};if(w.attachEvent){w.attachEvent('onload',l);}else{w.addEventListener('load',l,false);}}})();

        </script><style id="mm_style_mm_cdApiStyleId_1" media="screen" type="text/css"></style>
<script async="" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/hotjar-982604(1).js"></script><script async="" charset="utf-8" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/modules.bb88fc9b50ded24ae044.js"></script><style type="text/css">iframe#_hjRemoteVarsFrame {display: none !important; width: 1px !important; height: 1px !important; opacity: 0 !important; pointer-events: none !important;}</style><style></style><script src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/f(1).txt"></script><script src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/f(2).txt"></script><script id="schema" type="application/ld+json">{
	"@context": "https://schema.org",
	"@type": "book",
	"author": [
		"Fabrizio Romano"
	],
	"datePublished": "2018-06-29T06:10:00.000Z",
	"image": "https://d255esdrn735hr.cloudfront.net/sites/default/files/B10074_Ned_coccover.png",
	"name": "Object-oriented programming (OOP) - Learn Python Programming - Second Edition",
	"publisher": {
		"@type": "Organization",
		"name": "Packt",
		"logo": {
			"@type": "ImageObject",
			"url": "https://d3ginfw2u4xn7p.cloudfront.net/c825bf9a03a944639d91ecb1f0010fc4/images/white-packt.png"
		}
	},
	"isPartOf": "/book/application_development/9781788996662",
	"description": "It's been quite a long and hopefully nice journey and, by now, we should be ready to explore OOP. I'll use the definition from Kindler, E.; Krivy, I. (2011).",
	"isbn": "9781788996662",
	"bookFormat": "https://schema.org/EBook"
}</script></head><body class="prototype-nav home-body" ng-class="{
    'cover-background': currentPage === 'login' ||
        currentPage === 'create-account' ||
        currentPage === 'password-reset',
    'checkout': currentPage === 'checkout',
    'has-footer': currentPage !== 'login' &amp;&amp;
        currentPage !== 'create-account' &amp;&amp;
        currentPage !== 'password-reset' &amp;&amp;
        currentPage !== 'product',
    'has-bottom-pagination': currentPage === 'saved' ||
        currentPage === 'bookmarks' ||
        currentPage === 'purchases' ||
        currentPage === 'history',
    
    'sidebar-open': showSideBarOverlay,
    'home-body': currentPage != 'create-account' || !freeWeekend,
    'free-weekend': currentPage === 'create-account' &amp;&amp; freeWeekend,
     }"><prerender-ready class="ng-isolate-scope">
<script>
    window.prerenderReady = false;
</script>
</prerender-ready>
<script>
                window.dataLayer = window.dataLayer || [];
                (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
                })(window,document,'script','dataLayer','GTM-WJMM825');
            </script>
<script src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/mmapi.js" type="text/javascript"></script><script id="" type="text/javascript">window.dataLayer=window.dataLayer||[];window.dataLayer.push({originalLocation:document.location.protocol+"//"+document.location.hostname+document.location.pathname+document.location.search});</script><script id="" type="text/javascript">Element.prototype.matches||(Element.prototype.matches=Element.prototype.matchesSelector||Element.prototype.mozMatchesSelector||Element.prototype.msMatchesSelector||Element.prototype.oMatchesSelector||Element.prototype.webkitMatchesSelector||function(a){a=(this.document||this.ownerDocument).querySelectorAll(a);for(var b=a.length;0<=--b&&a.item(b)!==this;);return-1<b});</script><script id="mmpack.0" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/mmpackage-1.12.js" type="text/javascript"></script>

<script src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/cookieconsent.min.js" type="text/javascript"></script>

<link href="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/app.104d50d2c3a3114104d18ba8a565ba3d.bundle.css" rel="stylesheet"/>


<sidebar-overlay class="ng-isolate-scope" show="showSideBarOverlay"></sidebar-overlay>
<div class="page">
<div class="alertbox" id="alertbox"></div>
<div autoscroll="true" class="ng-scope" ng-view="" style="height:100%;">




<div class="book-page-wrapper ng-scope">
<div class="container book-page">

<div class="clearfix"></div>



<div class="container-fluid" id="book-wrapper">
<div class="ng-scope" ng-include="productController.contentView" onload="productController.onFinishLoadContent()"><div class="col-sm-12 ng-scope reader-container" id="reader-content" ng-class="{'reader-container': productController.productType === 'book'}" ng-show="productController.isContentAvailable" on-finish-page-render="productController.applyFontSize()">
<div class="row">
<div class="book-content" style="position:relative;">
<div class="ng-binding" ng-bind-html="productController.content"><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ch06lvl1sec63"></a>Object-oriented programming (OOP)</h2></div></div><hr/></div><p>It's been quite a long and <span>hopefully</span><a class="indexterm" id="id326008413"></a> nice journey and, by now, we should be ready to explore OOP. I'll use the definition from Kindler, E.; Krivy, I. (2011). <span class="emphasis"><em>Object-oriented simulation of systems with sophisticated control</em></span> by <span class="emphasis"><em>International Journal of General Systems</em></span>, and adapt it to Python:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em><span>Object-oriented programming</span> (OOP) is a programming paradigm based on the concept of "objects", which are data structures that contain data, in the form of attributes, and code, in the form of functions known as methods. A distinguishing feature of objects is that an object's method can access and often modify the data attributes of the object with which they are associated (objects have a notion of "self"). In OO programming, computer programs are designed by making them out of objects that interact with one another.</em></span></p></blockquote></div><p>Python has full support for this paradigm. Actually, as we have already said, <span class="emphasis"><em>everything in Python is an object</em></span>, so this shows that OOP is not just supported by Python, but it's a part of its very core.</p><p>The two main players in OOP are <span class="strong"><strong>objects</strong></span> and <span class="strong"><strong>classes</strong></span>. Classes are used to create objects (objects are instances of the classes from which they were created), so we could see them as instance factories. When objects are created by a class, they inherit the class attributes and methods. They represent concrete items in the program's domain.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec76"></a>The simplest Python class</h3></div></div></div><p>I will start with the simplest class <span>you</span><a class="indexterm" id="id326008358"></a> could ever write in Python:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="0"># oop/simplest.class.py
class Simplest():  # when empty, the braces are optional
    pass

print(type(Simplest))  # what type is this object?
simp = Simplest()  # we create an instance of Simplest: simp
print(type(simp))  # what type is simp?
# is simp an instance of Simplest?
print(type(simp) == Simplest)  # There's a better way for this</code></pre></div><p>Let's run the preceding code and explain it line by line:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="1"><span class="strong"><strong>$ python simplest.class.py</strong></span>
<span class="token tag"><span class="token tag"><span class="token punctuation"></span></span><span class="strong"><span class="token tag"><span class="token punctuation"></span></span><strong><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">'type'</span><span class="token punctuation">&gt;</span></strong><span class="token punctuation"></span></span><span class="token punctuation"></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation"></span></span><span class="strong"><span class="token tag"><span class="token punctuation"></span></span><strong><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">'__main__.Simplest'</span><span class="token punctuation">&gt;</span></strong><span class="token punctuation"></span></span><span class="token punctuation"></span></span>
<span class="strong"><strong>True</strong></span></code></pre></div><p>The <code class="literal">Simplest</code> class I defined has only the <code class="literal">pass</code> instruction in its body, which means it doesn't have any custom attributes or methods. Brackets after the name are optional if empty. I will print its type (<code class="literal">__main__</code> is the name of the scope in which top-level code executes), and I am aware that, in the comment, I wrote <span class="emphasis"><em>object</em></span> instead of <span class="emphasis"><em>class</em></span>. It turns out that, as you can see by the result of that <code class="literal">print</code>, <span class="emphasis"><em>classes are actually objects</em></span>. To be precise, they <span>are</span><a class="indexterm" id="id325919212"></a> instances of <code class="literal">type</code>. Explaining <span>this</span><a class="indexterm" id="id325916636"></a> concept would lead us to a talk about <span class="strong"><strong>metaclasses</strong></span> and <span class="strong"><strong>metaprogramming</strong></span>, advanced concepts that require a solid grasp of the fundamentals to be understood and are beyond the scope of this chapter. As usual, I mentioned it to leave a pointer for you, for when you'll be ready to dig deeper.</p><p>Let's go back to the example: I used <code class="literal">Simplest</code> to create an instance, <code class="literal">simp</code>. You can see that the syntax to create an instance is the same as we use to call a function. Then we print what type <code class="literal">simp</code> belongs to and we verify that <code class="literal">simp</code> is in fact an instance of <code class="literal">Simplest</code>. I'll show you a better way of doing this later on in the chapter.</p><p>Up to now, it's all very simple. What happens when we write <code class="literal">class ClassName(): pass</code>, though? Well, what Python does is create a class object and assign it a name. This is very similar to what happens when we declare a function using <code class="literal">def</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec77"></a>Class and object namespaces</h3></div></div></div><p>After the class <span>object</span><a class="indexterm" id="id325888052"></a> has been created (which usually happens <span>when</span><a class="indexterm" id="id325888060"></a> the module is first imported), it basically represents a namespace. We can call that class to create its instances. Each instance inherits the class attributes and methods and is given its own namespace. We already know that, to walk a namespace, all we need to do is to use the dot (<code class="literal">.</code>) operator.</p><p>Let's look at another example:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="2"># oop/class.namespaces.py
class Person:
    species = 'Human'

print(Person.species)  # Human
Person.alive = True  # Added dynamically!
print(Person.alive)  # True

man = Person()
print(man.species)  # Human (inherited)
print(man.alive)  # True (inherited)

Person.alive = False
print(man.alive)  # False (inherited)

man.name = 'Darth'
man.surname = 'Vader'
print(man.name, man.surname)  # Darth Vader</code></pre></div><p>In the preceding example, I have defined a class attribute called <code class="literal">species</code>. Any variable defined in the body of a class is an attribute that belongs to that class. In the code, I have also defined <code class="literal">Person.alive</code>, which is another class attribute. You can see that there is no restriction on accessing that attribute from the class. You can see that <code class="literal">man</code>, which is an instance of <code class="literal">Person</code>, inherits both of them, and reflects them instantly when they change.</p><p><code class="literal">man</code> has also two attributes that belong to its own <span>namespace</span><a class="indexterm" id="id325891820"></a> and therefore are called <span class="strong"><strong>instance attributes</strong></span>: <code class="literal">name</code> and <code class="literal">surname</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note55"></a>Note</h3><p>Class attributes are shared among all instances, while instance attributes are not; therefore, you should use class attributes to provide the states and behaviors to be shared by all instances, and use instance attributes for data that belongs just to one specific object.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec78"></a>Attribute shadowing</h3></div></div></div><p>When you <span>search</span><a class="indexterm" id="id325891889"></a> for an attribute in an object, if it is <span>not</span><a class="indexterm" id="id325891897"></a> found, Python keeps searching in the class that was used to create that object (and keeps searching until it's either found or the end of the inheritance chain is reached). This leads to an interesting shadowing behavior. Let's look at another example:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="3"># oop/class.attribute.shadowing.py
class Point:
    x = 10
    y = 7

p = Point()
print(p.x)  # 10 (from class attribute)
print(p.y)  # 7 (from class attribute)

p.x = 12  # p gets its own `x` attribute
print(p.x)  # 12 (now found on the instance)
print(Point.x)  # 10 (class attribute still the same)

del p.x  # we delete instance attribute
print(p.x)  # 10 (now search has to go again to find class attr)

p.z = 3  # let's make it a 3D point
print(p.z)  # 3

print(Point.z)
# AttributeError: type object 'Point' has no attribute 'z'</code></pre></div><p>The preceding code is very interesting. We have defined a class called <code class="literal">Point</code> with two class attributes, <code class="literal">x</code> and <code class="literal">y</code>. When we create an instance, <code class="literal">p</code>, you can see that we can print both <code class="literal">x</code> and <code class="literal">y</code> from the <code class="literal">p</code> namespace (<code class="literal">p.x</code> and <code class="literal">p.y</code>). What happens when we do that is Python doesn't find any <code class="literal">x</code> or <code class="literal">y</code> attributes on the instance, and therefore searches the class, and finds them there.</p><p>Then we give <code class="literal">p</code> its own <code class="literal">x</code> attribute by assigning <code class="literal">p.x = 12</code>. This behavior may appear a bit weird at first, but if you think about it, it's exactly the same as what happens in a function that declares <code class="literal">x = 12</code> when there is a global <code class="literal">x = 10</code> outside. We know that <code class="literal">x = 12</code> won't affect the global one, and for classes and instances, it is exactly the same.</p><p>After assigning <code class="literal">p.x = 12</code>, when we print it, the search doesn't need to read the class attributes, because <code class="literal">x</code> is found on the instance, therefore we get <code class="literal">12</code> printed out. We also print <code class="literal">Point.x</code>, which refers to <code class="literal">x</code> in the class namespace.</p><p>And then, we delete <code class="literal">x</code> from the <span>namespace</span><a class="indexterm" id="id325915837"></a> of <code class="literal">p</code>, which <span>means</span><a class="indexterm" id="id325915849"></a> that, on the next line, when we print it again, Python will go again and search for it in the class, because it won't be found in the instance any more.</p><p>The last three lines show you that assigning attributes to an instance doesn't mean that they will be found in the class. Instances get whatever is in the class, but the opposite is not true.</p><p>What do you think about putting the <code class="literal">x</code> and <code class="literal">y</code> coordinates as class attributes? Do you think it was a good idea? What if you added another instance of <code class="literal">Point</code>? Would that help to show why class attributes can be very useful?</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec79"></a>Me, myself, and I – using the self variable</h3></div></div></div><p>From within a class method, we can <span>refer</span><a class="indexterm" id="id325916598"></a> to an instance by means of a special argument, called <code class="literal">self</code> by convention. <code class="literal">self</code> is always the first attribute of an instance method. Let's examine this behavior together with how we can share, not just attributes, but methods with all instances:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="4"># oop/class.self.py
class Square:
    side = 8
    def area(self):  # self is a reference to an instance
        return self.side ** 2

sq = Square()
print(sq.area())  # 64 (side is found on the class)
print(Square.area(sq))  # 64 (equivalent to sq.area())

sq.side = 10
print(sq.area())  # 100 (side is found on the instance)</code></pre></div><p>Note how the <code class="literal">area</code> method is used by <code class="literal">sq</code>. The two calls, <code class="literal">Square.area(sq)</code> and <code class="literal">sq.area()</code>, are equivalent, and teach us how the mechanism works. Either you pass the instance to the method call (<code class="literal">Square.area(sq)</code>), which within the method will take the name <code class="literal">self</code>, or you can use a more comfortable syntax, <code class="literal">sq.area()</code>, and Python will translate that for you behind the scenes.</p><p>Let's look at a better example:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="5"># oop/class.price.py
class Price:
    def final_price(self, vat, discount=0):
        """Returns price after applying vat and fixed discount."""
        return (self.net_price * (100 + vat) / 100) - discount

p1 = Price()
p1.net_price = 100
print(Price.final_price(p1, 20, 10))  # 110 (100 * 1.2 - 10)
print(p1.final_price(20, 10))  # equivalent</code></pre></div><p>The preceding code shows you that nothing prevents us from using arguments when declaring methods. We can use the exact same syntax as we used with the function, but we need to remember that the first argument will <span>always</span><a class="indexterm" id="id326081518"></a> be the instance. We don't need to necessarily call it <code class="literal">self</code>, but it's the convention, and this is one of the few cases where it's very important to abide by it.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec80"></a>Initializing an instance</h3></div></div></div><p>Have you <span>noticed</span><a class="indexterm" id="id326081543"></a> how, before calling <code class="literal">p1.final_price(...)</code>, we had to assign <code class="literal">net_price</code> to <code class="literal">p1</code>? There is a better way to do it. In other languages, this <span>would</span><a class="indexterm" id="id326610824"></a> be called a <span class="strong"><strong>constructor</strong></span>, but in Python, it's not. It is actually an <span class="strong"><strong>initializer</strong></span>, since it <span>works</span><a class="indexterm" id="id326611844"></a> on an already-created instance, and therefore it's called <code class="literal">__init__</code>. It's a <span class="emphasis"><em>magic method</em></span>, which is run right after the object is created. Python objects also have a <code class="literal">__new__</code> method, which is the actual constructor. In practice, it's not so common to have to override it though, it's a practice that is mostly used when coding metaclasses, which as we mentioned, is a fairly advanced topic that we won't explore in the book:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="6"># oop/class.init.py
class Rectangle:
    def __init__(self, side_a, side_b):
        self.side_a = side_a
        self.side_b = side_b

    def area(self):
        return self.side_a * self.side_b

r1 = Rectangle(10, 4)
print(r1.side_a, r1.side_b)  # 10 4
print(r1.area())  # 40

r2 = Rectangle(7, 3)
print(r2.area())  # 21</code></pre></div><p>Things are finally starting to take shape. When an object is created, the <code class="literal">__init__</code> method is automatically run for us. In this case, I coded it so that when we create an object (by calling the class name like a function), we pass arguments to the creation call, like we would on any regular function call. The way we pass parameters follows the signature of the <code class="literal">__init__</code> method, and therefore, in the two creation statements, <code class="literal">10</code> and <code class="literal">7</code> will be <code class="literal">side_a</code> for <code class="literal">r1</code> and <code class="literal">r2</code>, respectively, while <code class="literal">4</code> and <code class="literal">3</code> will be <code class="literal">side_b</code>. You can see that the call to <code class="literal">area()</code> from <code class="literal">r1</code> and <code class="literal">r2</code> reflects that they have different instance arguments. Setting up objects in this way is much nicer and more convenient.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec81"></a>OOP is about code reuse</h3></div></div></div><p>By now it should be pretty clear: <span class="emphasis"><em>OOP is all about code reuse</em></span>. We define a class, we create instances, and those instances use methods that are defined only in the class. They will behave differently according to how the instances have been set up by the initializer.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec13"></a>Inheritance and composition</h4></div></div></div><p>But this is just <span>half</span><a class="indexterm" id="id326096976"></a> of the story, <span class="emphasis"><em>OOP is much more powerful</em></span>. We have two <span>main</span><a class="indexterm" id="id326096987"></a> design constructs to exploit: inheritance and composition.</p><p><span class="strong"><strong>Inheritance</strong></span> means that two <span>objects</span><a class="indexterm" id="id326104273"></a> are related by means of an <span class="emphasis"><em>Is-A</em></span> type of relationship. On the other hand, <span class="strong"><strong>composition</strong></span> means that two <span>objects</span><a class="indexterm" id="id326104286"></a> are related by means of a <span class="emphasis"><em>Has-A</em></span> type of relationship. It's all very easy to explain with an example:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="7"># oop/class_inheritance.py
class <span class="strong"><strong>Engine</strong></span>:
    def start(self):
        pass

    def stop(self):
        pass

class ElectricEngine(<span class="strong"><strong>Engine</strong></span>):  # Is-A Engine
    pass

class V8Engine(<span class="strong"><strong>Engine</strong></span>):  # Is-A Engine
    pass

class <span class="strong"><strong>Car</strong></span>:
    engine_cls = Engine

    def __init__(self):
        self.engine = self.engine_cls()  # Has-A Engine

    def start(self):
        print(
            'Starting engine {0} for car {1}... Wroom, wroom!'
            .format(
                self.engine.__class__.__name__,
                self.__class__.__name__)
        )
        self.engine.start()

    def stop(self):
        self.engine.stop()

class RaceCar(<span class="strong"><strong>Car</strong></span>):  # Is-A Car
    engine_cls = V8Engine

class CityCar(<span class="strong"><strong>Car</strong></span>):  # Is-A Car
    engine_cls = ElectricEngine

class F1Car(<span class="strong"><strong>RaceCar</strong></span>):  # Is-A RaceCar and also Is-A Car
    pass  # engine_cls same as parent

car = Car()
racecar = RaceCar()
citycar = CityCar()
f1car = F1Car()
cars = [car, racecar, citycar, f1car]

for car in cars:
    car.start()

""" Prints:
Starting engine Engine for car Car... Wroom, wroom!
Starting engine V8Engine for car RaceCar... Wroom, wroom!
Starting engine ElectricEngine for car CityCar... Wroom, wroom!
Starting engine V8Engine for car F1Car... Wroom, wroom!
"""</code></pre></div><p>The preceding example shows you both the <span class="emphasis"><em>Is-A</em></span> and <span class="emphasis"><em>Has-A</em></span> types of relationships between objects. First of all, let's consider <code class="literal">Engine</code>. It's a simple class that has two methods, <code class="literal">start</code> and <code class="literal">stop</code>. We then define <code class="literal">ElectricEngine</code> and <code class="literal">V8Engine</code>, which both inherit from <code class="literal">Engine</code>. You can see that by the fact that when we define them, we put <code class="literal">Engine</code> within the brackets after the class name.</p><p>This means that both <code class="literal">ElectricEngine</code> and <code class="literal">V8Engine</code> inherit attributes and methods from the <code class="literal">Engine</code> class, which is said to be their <span class="strong"><strong>base class</strong></span>.</p><p>The same happens with cars. <code class="literal">Car</code> is a base class for both <code class="literal">RaceCar</code> and <code class="literal">CityCar</code>. <code class="literal">RaceCar</code> is also the base class for <code class="literal">F1Car</code>. Another way of saying this is that <code class="literal">F1Car</code> inherits from <code class="literal">RaceCar</code>, which inherits from <code class="literal">Car</code>. Therefore, <code class="literal">F1Car</code> <span class="emphasis"><em>Is-A </em></span><code class="literal">RaceCar</code> and <code class="literal">RaceCar</code> <span class="emphasis"><em>Is-A </em></span><code class="literal">Car</code>. Because of the transitive property, we can say that <code class="literal">F1Car</code><span class="emphasis"><em> Is-A </em></span><code class="literal">Car</code> as well. <code class="literal">CityCar</code> too, <span class="emphasis"><em>Is-A </em></span><code class="literal">Car</code>.</p><p>When we define <code class="literal">class A(B): pass</code>, we say <code class="literal">A</code> is the <span class="emphasis"><em>child</em></span> of <code class="literal">B</code>, and <code class="literal">B</code> is the <span class="emphasis"><em>parent</em></span> of <code class="literal">A</code>. The <span class="emphasis"><em>parent</em></span> and <span class="emphasis"><em>base</em></span> classes are synonyms, are <span class="emphasis"><em>child</em></span> and <span class="emphasis"><em>derived</em></span>. Also, we say that a class inherits from another class, or that it extends it.</p><p>This is the inheritance mechanism.</p><p>On the other hand, let's go back to the code. Each class has a class attribute, <code class="literal">engine_cls</code>, which is a reference to the engine class we want to assign to each type of car. <code class="literal">Car</code> has a generic <code class="literal">Engine</code>, while the two race cars have a powerful V8 engine, and the city car has an electric one.</p><p>When a car is created in the initializer method, <code class="literal">__init__</code>, we create an instance of whatever engine class is assigned to the car, and set it as the <code class="literal">engine</code> instance attribute.</p><p>It makes sense to have <code class="literal">engine_cls</code> shared among all class instances because it's quite likely that the same instances of a car will have the same kind of engine. On the other hand, it wouldn't be good to have one single engine (an instance of any <code class="literal">Engine</code> class) as a class attribute, because we would be sharing one <span>engine</span><a class="indexterm" id="id326181446"></a> among all instances, which <span>is</span><a class="indexterm" id="id326181454"></a> incorrect.</p><p>The type of relationship between a car and its engine is a <span class="emphasis"><em>Has-A</em></span> type. A car <span class="emphasis"><em>Has-A</em></span> engine. This is called <span class="strong"><strong>composition</strong></span>, and <span>reflects</span><a class="indexterm" id="id326181476"></a> the fact that objects can be <span>made</span><a class="indexterm" id="id326181483"></a> of many other objects. A car <span class="emphasis"><em>Has-A</em></span> engine, gears, wheels, a frame, doors, seats, and so on.</p><p>When designing OOP code, it is of vital importance to describe objects in this way so that we can use inheritance and composition correctly to structure our code in the best way.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note56"></a>Note</h3><p>Notice how I had to avoid having dots in the <code class="literal">class_inheritance.py</code> script name, as dots in module names make it imports difficult. Most modules in the source code of the book are meant to be run as standalone scripts, therefore I chose to add dots to enhance readability when possible, but in general, you want to avoid dots in your module names.</p></div><p>Before we leave this paragraph, let's check whether I told you the truth with another example:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="8"># oop/class.issubclass.isinstance.py
from class_inheritance import Car, RaceCar, F1Car

car = Car()
racecar = RaceCar()
f1car = F1Car()
cars = [(car, 'car'), (racecar, 'racecar'), (f1car, 'f1car')]
car_classes = [Car, RaceCar, F1Car]

for car, car_name in cars:
    for class_ in car_classes:
        belongs = isinstance(car, class_)
        msg = 'is a' if belongs else 'is not a'
        print(car_name, msg, class_.__name__)

""" Prints:
<span class="strong"><strong>car is a Car</strong></span>
car is not a RaceCar
car is not a F1Car
<span class="strong"><strong>racecar is a Car</strong></span>
<span class="strong"><strong>racecar is a RaceCar</strong></span>
racecar is not a F1Car
<span class="strong"><strong>f1car is a Car</strong></span>
<span class="strong"><strong>f1car is a RaceCar</strong></span>
<span class="strong"><strong>f1car is a F1Car</strong></span>
"""</code></pre></div><p>As you can see, <code class="literal">car</code> is just an instance of <code class="literal">Car</code>, while <code class="literal">racecar</code> is an instance of <code class="literal">RaceCar</code> (and of <code class="literal">Car</code>, by extension) and <code class="literal">f1car</code> is an instance of <code class="literal">F1Car</code> (and of both <code class="literal">RaceCar</code> and <code class="literal">Car</code>, by extension). A <span class="emphasis"><em>banana</em></span> is an instance of <span class="emphasis"><em>banana</em></span>. But, also, it is a <span class="emphasis"><em>Fruit</em></span>. Also, it is <span class="emphasis"><em>Food</em></span>, right? This is the same concept. To check whether an object is an instance of a class, use the <code class="literal">isinstance</code> method. It is recommended over sheer type comparison: <code class="literal">(type(object) == Class)</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note57"></a>Note</h3><p>Notice I have left out the prints you get when instantiating the cars. We saw them in the previous example.</p></div><p>Let's also check inheritance–same setup, different logic in the <code class="literal">for</code> loops:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="9"># oop/class.issubclass.isinstance.py
for class1 in car_classes:
    for class2 in car_classes:
        is_subclass = issubclass(class1, class2)
        msg = '{0} a subclass of'.format(
            'is' if is_subclass else 'is not')
        print(class1.__name__, msg, class2.__name__)

""" Prints:
<span class="strong"><strong>Car is a subclass of Car</strong></span>
Car is not a subclass of RaceCar
Car is not a subclass of F1Car
<span class="strong"><strong>RaceCar is a subclass of Car</strong></span>
<span class="strong"><strong>RaceCar is a subclass of RaceCar</strong></span>
RaceCar is not a subclass of F1Car
<span class="strong"><strong>F1Car is a subclass of Car</strong></span>
<span class="strong"><strong>F1Car is a subclass of RaceCar</strong></span>
<span class="strong"><strong>F1Car is a subclass of F1Car</strong></span>
"""</code></pre></div><p>Interestingly, we learn that <span class="emphasis"><em>a class is a subclass of itself</em></span>. Check the <span>output</span><a class="indexterm" id="id326208019"></a> of the <span>preceding</span><a class="indexterm" id="id326208025"></a> example to see that it <span>matches</span><a class="indexterm" id="id326208032"></a> the <span>explanation</span><a class="indexterm" id="id326208040"></a> I provided.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note58"></a>Note</h3><p>One thing to notice about conventions is that class names are always written using <code class="literal">CapWords</code>, which means <code class="literal">ThisWayIsCorrect</code>, as opposed to functions and methods, which are written <code class="literal">this_way_is_correct</code>. Also, when in the code, you want to use a name that is a Python-reserved keyword or a built-in function or class, the convention is to add a trailing underscore to the name. In the first <code class="literal">for</code> loop example, I'm looping through the class names using <code class="literal">for class_ in ...</code>, because <code class="literal">class</code> is a reserved word. But you already knew all this because you have thoroughly studied PEP8, right?</p></div><p>To help you picture the difference between <span class="emphasis"><em>Is-A</em></span> and <span class="emphasis"><em>Has-A</em></span>, take a look at the following diagram:</p><div class="mediaobject"><img src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/6613c0c9-5062-4b22-b702-9fc80342ca4a.png"/></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec82"></a>Accessing a base class</h3></div></div></div><p>We've already seen class declarations, such as <code class="literal">class ClassA: pass</code> and <code class="literal">class ClassB(BaseClassName): pass</code>. When we don't <span>specify</span><a class="indexterm" id="id326213976"></a> a base class explicitly, Python will set the special <span class="strong"><strong>object</strong></span> class as the base class for the one we're defining. Ultimately, all classes derive from an object. Note that, if you don't specify a base class, brackets are optional.</p><p>Therefore, writing <code class="literal">class A: pass</code> or <code class="literal">class A(): pass</code> or <code class="literal">class A(object): pass</code> is exactly the same thing. The <span class="emphasis"><em>object</em></span> class is a special class in that it has the methods that are common to all Python classes, and it doesn't allow you to set any attributes on it.</p><p>Let's see how we can access a base class from within a class:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="10"># oop/super.duplication.py
class Book:
    def __init__(self, title, publisher, pages):
        self.title = title
        self.publisher = publisher
        self.pages = pages

class Ebook(Book):
    def __init__(self, title, publisher, pages, format_):
        self.title = title
        self.publisher = publisher
        self.pages = pages
        self.format_ = format_</code></pre></div><p>Take a look at the preceding code. Three of the input parameters are duplicated in <code class="literal">Ebook</code>. This is quite bad practice because we now have two sets of instructions that are doing the same thing. Moreover, any change in the signature of <code class="literal">Book.__init__</code> will not be reflected in <code class="literal">Ebook</code>. We know that <code class="literal">Ebook</code><span class="emphasis"><em> Is-A </em></span><code class="literal">Book</code>, and therefore we would probably want changes to be reflected in the children classes.</p><p>Let's see one way to fix this issue:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="11"># oop/super.explicit.py
class Book:
    def __init__(self, title, publisher, pages):
        self.title = title
        self.publisher = publisher
        self.pages = pages

class Ebook(Book):
    def __init__(self, title, publisher, pages, format_):
<span class="strong"><strong>Book.__init__(self, title, publisher, pages)</strong></span>
        self.format_ = format_

ebook = Ebook(
    'Learn Python Programming', 'Packt Publishing', 500, 'PDF')
print(ebook.title)  # Learn Python Programming
print(ebook.publisher)  # Packt Publishing
print(ebook.pages)  # 500
print(ebook.format_)  # PDF</code></pre></div><p>Now, that's better. We have removed that nasty duplication. Basically, we tell Python to call the <code class="literal">__init__</code> method of the <code class="literal">Book</code> class, and we feed <code class="literal">self</code> to the call, making sure that we bind that call to the present instance.</p><p>If we modify the logic within the <code class="literal">__init__</code> method of <code class="literal">Book</code>, we don't need to touch <code class="literal">Ebook</code>, it will auto-adapt to the change.</p><p>This approach is good, but we can still do a bit better. Say that we change the name of  <code class="literal">Book</code> to <code class="literal">Liber</code>, because we've fallen in love <span>with</span><a class="indexterm" id="id326223767"></a> Latin. We have to change the <code class="literal">__init__</code> method of <code class="literal">Ebook</code> to reflect the change. This can be avoided by using <code class="literal">super</code>:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="12"># oop/super.implicit.py
class Book:
    def __init__(self, title, publisher, pages):
        self.title = title
        self.publisher = publisher
        self.pages = pages

class Ebook(Book):
    def __init__(self, title, publisher, pages, format_):
        super().__init__(title, publisher, pages)
        # Another way to do the same thing is:
        # super(Ebook, self).__init__(title, publisher, pages)
        self.format_ = format_

ebook = Ebook(
    'Learn Python Programming', 'Packt Publishing', 500, 'PDF')
print(ebook.title) # Learn Python Programming
print(ebook.publisher) # Packt Publishing
print(ebook.pages) # 500
print(ebook.format_) # PDF</code></pre></div><p><code class="literal">super</code> is a function that returns a proxy object that delegates method calls to a parent or sibling class. In this case, it will delegate that call to <code class="literal">__init__</code> to the <code class="literal">Book</code> class, and the beauty of this method is that now we're even free to change <code class="literal">Book</code> to <code class="literal">Liber</code> without having to touch the logic in the <code class="literal">__init__</code> method of <code class="literal">Ebook</code>.</p><p>Now that we know how to access a base class from a child, let's explore Python's multiple inheritance.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec83"></a>Multiple inheritance</h3></div></div></div><p>Apart from <span>composing</span><a class="indexterm" id="id326235257"></a> a class using more than one base class, what is of interest here is how an attribute search is performed. Take a look at the following diagram:</p><div class="mediaobject"><img src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/fe77d6fe-ca61-4c5f-8ea9-542a7c9cca26.png"/></div><p>As you can see, <code class="literal">Shape</code> and <code class="literal">Plotter</code> act as base classes for all the others. <code class="literal">Polygon</code> inherits directly from them, <code class="literal">RegularPolygon</code> inherits from <code class="literal">Polygon</code>, and both <code class="literal">RegularHexagon</code> and <code class="literal">Square</code> inherit from <code class="literal">RegulaPolygon</code>. Note also that <code class="literal">Shape</code> and <code class="literal">Plotter</code> implicitly inherit from <code class="literal">object</code>, therefore we have what is called a <span class="strong"><strong>diamond</strong></span> or, in simpler terms, more than one path to reach a base class. We'll see why this matters in a few moments. Let's translate it into some simple code:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="13"># oop/multiple.inheritance.py
class Shape:
    geometric_type = 'Generic Shape'
    def area(self):  # This acts as placeholder for the interface
        raise NotImplementedError
    def get_geometric_type(self):
        return self.geometric_type

class Plotter:
    def plot(self, ratio, topleft):
        # Imagine some nice plotting logic here...
        print('Plotting at {}, ratio {}.'.format(
            topleft, ratio))

class Polygon(Shape, Plotter):  # base class for polygons
    geometric_type = 'Polygon'

class RegularPolygon(Polygon):  # Is-A Polygon
    geometric_type = 'Regular Polygon'
    def __init__(self, side):
        self.side = side

class RegularHexagon(RegularPolygon):  # Is-A RegularPolygon
    geometric_type = 'RegularHexagon'
    def area(self):
        return 1.5 * (3 ** .5 * self.side ** 2)

class Square(RegularPolygon):  # Is-A RegularPolygon
    geometric_type = 'Square'
    def area(self):
        return self.side * self.side

hexagon = RegularHexagon(10)
print(hexagon.area())  # 259.8076211353316
print(hexagon.get_geometric_type())  # RegularHexagon
hexagon.plot(0.8, (75, 77))  # Plotting at (75, 77), ratio 0.8.

square = Square(12)
print(square.area())  # 144
print(square.get_geometric_type())  # Square
square.plot(0.93, (74, 75))  # Plotting at (74, 75), ratio 0.93.</code></pre></div><p>Take a look at the preceding code: the <code class="literal">Shape</code> class has one attribute, <code class="literal">geometric_type</code>, and two methods: <code class="literal">area</code> and <code class="literal">get_geometric_type</code>. It's quite common to use base classes (such as <code class="literal">Shape</code>, in our example) to define an <span class="emphasis"><em>interface</em></span>–methods for which children must provide an implementation. There are different and <span>better</span><a class="indexterm" id="id326241830"></a> ways to do this, but I want to keep this example as simple as possible.</p><p>We also have the <code class="literal">Plotter</code> class, which adds the <code class="literal">plot</code> method, thereby providing plotting capabilities for any class that inherits from it. Of course, the <code class="literal">plot</code> implementation is just a dummy <code class="literal">print</code> in this example. The first interesting class is <code class="literal">Polygon</code>, which inherits from both <code class="literal">Shape</code> and <code class="literal">Plotter</code>.</p><p>There are many types of polygons, one of which is the regular one, which is both equiangular (all angles are equal) and equilateral (all sides are equal), so we create the <code class="literal">RegularPolygon</code> class that inherits from <code class="literal">Polygon</code>. For a regular polygon, where all sides are equal, we can implement a simple <code class="literal">__init__</code> method on <code class="literal">RegularPolygon</code>, which takes the length of the side. Finally, we create the <code class="literal">RegularHexagon</code> and <code class="literal">Square</code> classes, which both inherit from <code class="literal">RegularPolygon</code>.</p><p>This structure is quite long, but hopefully gives you an idea of how to specialize the classification of your objects when you design the code.</p><p>Now, please take a look at the last eight lines. Note that when I call the <code class="literal">area</code> method on <code class="literal">hexagon</code> and <code class="literal">square</code>, I get the correct area for both. This is because they both provide the correct implementation logic for it. Also, I can call <code class="literal">get_geometric_type</code> on both of them, even though it is not defined on their classes, and Python has to go all the way up to <code class="literal">Shape</code> to find an implementation for it. Note that, even though the implementation is provided in the <code class="literal">Shape</code> class, the <code class="literal">self.geometric_type</code> used for the return value is correctly taken from the caller instance.</p><p>The <code class="literal">plot</code> method calls are also interesting, and show you how you can enrich your objects with capabilities they wouldn't otherwise have. This technique is very popular in web frameworks such as Django (which we'll explore <span><a class="link" href="https://subscription.packtpub.com/book/application_development/9781788996662/14" linkend="ch14">Chapter 14</a>, <span class="emphasis"><em>Web Development</em></span></span>), which provides special classes called <span class="strong"><strong>mixins</strong></span>, whose capabilities you can just use out of the box. All you have to do is to define the desired mixin as one the base classes for your own, and that's it.</p><p>Multiple inheritance is powerful, but can also get really messy, so we need to make sure we understand what happens when we use it.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec14"></a>Method resolution order</h4></div></div></div><p>By now, we know that <span>when</span><a class="indexterm" id="id326241945"></a> you ask for <code class="literal">someobject.attribute</code> and <code class="literal">attribute</code> is not found on that object, Python starts searching in the class that <code class="literal">someobject</code> was created from. If it's not there either, Python searches up the inheritance chain until either <code class="literal">attribute</code> is found or the <code class="literal">object</code> class is reached. This is quite simple to understand if the inheritance chain is only composed of single-inheritance steps, which means that classes have only one parent. However, when multiple inheritance is involved, there are cases when it's not straightforward to predict what will be the next class that will be searched for if an attribute is not found.</p><p>Python provides a way to always know the order in which <span>classes</span><a class="indexterm" id="id326245762"></a> are searched on attribute lookup: the <span class="strong"><strong>Method Resolution Order</strong></span> (<span class="strong"><strong>MRO</strong></span>).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note59"></a>Note</h3><p>The MRO is the order in which base classes are searched for a member during lookup. From version 2.3, Python uses an algorithm called <span class="strong"><strong>C3</strong></span>, which guarantees monotonicity.
In Python 2.2, <span class="emphasis"><em>new-style classes</em></span> were introduced. The way you write a new-style class in Python 2.* is to define it with an explicit <code class="literal">object</code> base class. Classic classes were not explicitly inheriting from <code class="literal">object</code> and have been removed in Python 3. One of the differences between classic and new-style classes in Python 2.* is that new-style classes are searched with the new MRO.</p></div><p>With regards to the previous example, let's see the MRO for the <code class="literal">Square</code> class:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="14"># oop/multiple.inheritance.py
print(square.__class__.__mro__)
# prints:
# (<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">'__main__.Square'</span><span class="token punctuation">&gt;</span></span>, <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">'__main__.RegularPolygon'</span><span class="token punctuation">&gt;</span></span>,
# <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">'__main__.Polygon'</span><span class="token punctuation">&gt;</span></span>, <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">'__main__.Shape'</span><span class="token punctuation">&gt;</span></span>,
# <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">'__main__.Plotter'</span><span class="token punctuation">&gt;</span></span>, <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">'object'</span><span class="token punctuation">&gt;</span></span>)</code></pre></div><p>To get to the MRO of a class, we can go from the instance to its <code class="literal">__class__</code> attribute, and from that to its <code class="literal">__mro__</code> attribute. Alternatively, we could have called <code class="literal">Square.__mro__</code>, or <code class="literal">Square.mro()</code> directly, but if you have to do it dynamically, it's more likely you will have an object than a class.</p><p>Note that the only point of doubt is the bisection after <code class="literal">Polygon</code>, where the inheritance chain breaks into two ways: one leads to <code class="literal">Shape</code> and the other to <code class="literal">Plotter</code>. We know by scanning the MRO for the <code class="literal">Square</code> class that <code class="literal">Shape</code> is searched before <code class="literal">Plotter</code>.</p><p>Why is this important? Well, consider the following code:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="15"># oop/mro.simple.py
class A:
    label = 'a'

class B(A):
    label = 'b'

class C(A):
    label = 'c'

class D(B, C):
    pass

d = D()
print(d.label)  # Hypothetically this could be either 'b' or 'c'</code></pre></div><p>Both <code class="literal">B</code> and <code class="literal">C</code> inherit from <code class="literal">A</code>, and <code class="literal">D</code> inherits from both <code class="literal">B</code> and <code class="literal">C</code>. This means that the lookup for the <code class="literal">label</code> attribute can reach the top (<code class="literal">A</code>) through either <code class="literal">B</code> or <code class="literal">C</code>. According to which is reached first, we get a different result.</p><p>So, in the preceding example, we get <code class="literal">'b'</code>, which is what we were expecting, since <code class="literal">B</code> is the leftmost one among the base classes of <code class="literal">D</code>. But what happens if I remove the <code class="literal">label</code> attribute from <code class="literal">B</code>? This would be a confusing situation: will the algorithm go all the way up to <code class="literal">A</code> or will it get to <code class="literal">C</code> first? Let's find out:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="16"># oop/mro.py
class A:
    label = 'a'

class B(A):
    pass  # was: label = 'b'

class C(A):
    label = 'c'

class D(B, C):
    pass

d = D()
print(d.label)  # 'c'
print(d.__class__.mro())  # notice another way to get the MRO
# prints:
# [<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">'__main__.D'</span><span class="token punctuation">&gt;</span></span>, <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">'__main__.B'</span><span class="token punctuation">&gt;</span></span>,
# <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">'__main__.C'</span><span class="token punctuation">&gt;</span></span>, <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">'__main__.A'</span><span class="token punctuation">&gt;</span></span>, <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">'object'</span><span class="token punctuation">&gt;</span></span>]</code></pre></div><p>So, we learn <span>that</span><a class="indexterm" id="id326303771"></a> the MRO is <code class="literal">D</code>-<code class="literal">B</code>-<code class="literal">C</code>-<code class="literal">A</code>-<code class="literal">object</code>, which means <span>when</span><a class="indexterm" id="id326303796"></a> we ask for <code class="literal">d.label</code>, we get <code class="literal">'c'</code>, which is correct.</p><p>In day-to-day programming, it is not common to have to deal with the MRO, but the first time you fight against some mixin from a framework, I promise you'll be glad I spent a paragraph explaining it.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec84"></a>Class and static methods</h3></div></div></div><p>So far, we have <span>coded</span><a class="indexterm" id="id326304160"></a> classes with attributes in the form of data and instance methods, but there are two other types of methods that we can place inside a class: <span class="strong"><strong>static methods</strong></span> and <span class="strong"><strong>class methods</strong></span>.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec15"></a>Static methods</h4></div></div></div><p>As you may recall, when you <span>create</span><a class="indexterm" id="id326304183"></a> a class object, Python assigns a name to it. That name acts as a namespace, and sometimes it makes sense to group functionalities under it. Static methods are perfect for this use case since, unlike instance methods, they are not passed any special argument. Let's look at an example of an imaginary <code class="literal">StringUtil</code> class:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="17"># oop/static.methods.py
class StringUtil:

    @staticmethod
    def is_palindrome(s, case_insensitive=True):
        # we allow only letters and numbers
        s = ''.join(c for c in s if c.isalnum())  # Study this!
        # For case insensitive comparison, we lower-case s
        if case_insensitive:
            s = s.lower()
        for c in range(len(s) // 2):
            if s[c] != s[-c -1]:
                return False
        return True

    @staticmethod
    def get_unique_words(sentence):
        return set(sentence.split())

print(StringUtil.is_palindrome(
    'Radar', case_insensitive=False))  # False: Case Sensitive
print(StringUtil.is_palindrome('A nut for a jar of tuna'))  # True
print(StringUtil.is_palindrome('Never Odd, Or Even!'))  # True
print(StringUtil.is_palindrome(
    'In Girum Imus Nocte Et Consumimur Igni')  # Latin! Show-off!
)  # True

print(StringUtil.get_unique_words(
    'I love palindromes. I really really love them!'))
# {'them!', 'really', 'palindromes.', 'I', 'love'}</code></pre></div><p>The preceding code is quite interesting. First of all, we learn that static methods are created by simply applying the <code class="literal">staticmethod</code> decorator to them. You can see that they aren't passed any special argument so, apart from the decoration, they really just look like functions.</p><p>We have a class, <code class="literal">StringUtil</code>, that acts as a container for functions. Another approach would be to have a separate module with functions inside. It's really a matter of preference most of the time.</p><p>The logic inside <code class="literal">is_palindrome</code> should be straightforward for you to understand by now, but, just in case, let's go through it. First, we remove all characters from <code class="literal">s</code> that are neither letters nor numbers. In order to do this, we use the <code class="literal">join</code> method of a string object (an empty string object, in this case). By calling <code class="literal">join</code> on an empty string, the result is that all elements in the iterable you pass to <code class="literal">join</code> will be concatenated together. We feed <code class="literal">join</code> a generator expression that says to take any character from <code class="literal">s</code> if the character is either alphanumeric or a number. This is because, in palindrome sentences, we want to discard anything that is not a character or a number.</p><p>We then lowercase <code class="literal">s</code> if <code class="literal">case_insensitive</code> is <code class="literal">True</code>, and then we proceed to check whether it is a palindrome. In order to do this, we compare the first and last characters, then the second and the second to last, and so on. If at any point we find a difference, it means the string isn't a palindrome and therefore we can return <code class="literal">False</code>. On the other hand, if we exit the <code class="literal">for</code> loop normally, it means no differences were found, and we can therefore say the string is a palindrome.</p><p>Notice that this code works <span>correctly</span><a class="indexterm" id="id326304257"></a> regardless of the length of the string; that is, if the length is odd or even. <code class="literal">len(s) // 2</code> reaches half of <code class="literal">s</code>, and if <code class="literal">s</code> is an odd amount of characters long, the middle one won't be checked (such as in <span class="emphasis"><em>RaDaR</em></span>, <span class="emphasis"><em>D</em></span> is not checked), but we don't care; it would be compared with itself so it's always passing that check.</p><p><code class="literal">get_unique_words</code> is much simpler: it just returns a set to which we feed a list with the words from a sentence. The <code class="literal">set</code> class removes any duplication for us, so we don't need to do anything else.</p><p>The <code class="literal">StringUtil</code> class provides us a nice container namespace for methods that are meant to work on strings. I could have coded a similar example with a <code class="literal">MathUtil</code> class, and some static methods to work on numbers, but I wanted to show you something different.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl3sec16"></a>Class methods</h4></div></div></div><p>Class methods are slightly different from <span>static</span><a class="indexterm" id="id326331953"></a> methods in that, like instance methods, they also take a special first argument, but in this case, it is the class object itself. A very common use case for coding class methods is to provide factory capability to a class. Let's see an example:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="18"># oop/class.methods.factory.py
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    @classmethod
    def from_tuple(cls, coords):  # cls is Point
        return cls(*coords)

    @classmethod
    def from_point(cls, point):  # cls is Point
        return cls(point.x, point.y)


p = Point.from_tuple((3, 7))
print(p.x, p.y)  # 3 7
q = Point.from_point(p)
print(q.x, q.y)  # 3 7</code></pre></div><p>In the preceding code, I showed you how to use a class method to create a factory for the class. In this case, we want to create a <code class="literal">Point</code> instance by passing both coordinates (regular creation <code class="literal">p = Point(3, 7)</code>), but we also want to be able to create an instance by passing a tuple (<code class="literal">Point.from_tuple</code>) or another instance (<code class="literal">Point.from_point</code>).</p><p>Within the two class methods, the <code class="literal">cls</code> argument refers to the <code class="literal">Point</code> class. As with the instance method, which takes <code class="literal">self</code> as the first argument, the class method takes a <code class="literal">cls</code> argument. Both <code class="literal">self</code> and <code class="literal">cls</code> are named after a convention that you are not forced to follow but are strongly encouraged to respect. This is something that no Python coder would change because it is so strong a convention that parsers, linters, and any tool that automatically does something with your code would expect, so it's much better to stick to it.</p><p>Class and static methods play well together. Static methods are actually quite helpful in breaking up the logic of a class method to improve its layout. Let's see an example by refactoring the <code class="literal">StringUtil</code> class:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="19"># oop/class.methods.split.py
class StringUtil:

    @classmethod
    def is_palindrome(cls, s, case_insensitive=True):
        s = cls._strip_string(s)
        # For case insensitive comparison, we lower-case s
        if case_insensitive:
            s = s.lower()
        return cls._is_palindrome(s)

    @staticmethod
    def _strip_string(s):
        return ''.join(c for c in s if c.isalnum())

    @staticmethod
    def _is_palindrome(s):
        for c in range(len(s) // 2):
            if s[c] != s[-c -1]:
                return False
        return True

    @staticmethod
    def get_unique_words(sentence):
        return set(sentence.split())

print(StringUtil.is_palindrome('A nut for a jar of tuna'))  # True
print(StringUtil.is_palindrome('A nut for a jar of beans'))  # False</code></pre></div><p>Compare this code with the previous version. First of all, note that even though <code class="literal">is_palindrome</code> is now a class method, we call it in the same way we were calling it when it was a static one. The reason why we changed it to a class method is that after factoring out a couple of pieces of logic (<code class="literal">_strip_string</code> and <code class="literal">_is_palindrome</code>), we <span>need</span><a class="indexterm" id="id326332365"></a> to get a reference to them, and if we have no <code class="literal">cls</code> in our method, the only option would be to call them like this: <code class="literal">StringUtil._strip_string(...)</code> and <code class="literal">StringUtil._is_palindrome(...)</code>, which is not good practice, because we would hardcode the class name in the <code class="literal">is_palindrome</code> method, thereby putting ourselves in the position of having to modify it whenever we want to change the class name. Using <code class="literal">cls</code> will act as the class name, which means our code won't need any amendments.</p><p>Notice how the new logic reads much better than the previous version. Moreover, notice that, by naming the <span class="emphasis"><em>factored-out</em></span> methods with a leading underscore, I am hinting that those methods are not supposed to be called from outside the class, but this will be the subject of the next paragraph.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec85"></a>Private methods and name mangling</h3></div></div></div><p>If you have any background <span>with</span><a class="indexterm" id="id326332403"></a> languages like Java, C#, or C++, then you <span>know</span><a class="indexterm" id="id326332411"></a> they allow the programmer to assign a privacy status to attributes (both data and methods). Each language has its own slightly different flavor for this, but the gist is that public attributes are accessible from any point in the code, while private ones are accessible only within the scope they are defined in.</p><p>In Python, there is no such thing. Everything is public; therefore, we rely on <span>conventions</span><a class="indexterm" id="id326332423"></a> and on a mechanism called <span class="strong"><strong>name mangling</strong></span>.</p><p>The convention is as follows: if an attribute's name has no leading underscores, it is considered public. This means you can access it and modify it freely. When the name has one leading underscore, the attribute is considered private, which means it's probably meant to be used internally and you should not use it or modify it from the outside. A very common use case for private attributes are helper methods that are supposed to be used by public ones (possibly in call chains in conjunction with other methods), and internal data, such as scaling factors, or any other data that ideally we would put in a constant (a variable that cannot change, but, surprise, surprise, Python doesn't have those either).</p><p>This characteristic usually scares people from other backgrounds off; they feel threatened by the lack of privacy. To be honest, in my whole professional experience with Python, I've never heard anyone screaming "<span class="emphasis"><em>oh my God, we have a terrible bug because Python lacks private attributes!</em></span>" Not once, I swear.</p><p>That said, the call for privacy actually makes sense because without it, you risk introducing bugs into your code for real. Let me show you what I mean:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="20"># oop/private.attrs.py
class A:
    def __init__(self, factor):
        self._factor = factor

    def op1(self):
        print('Op1 with factor {}...'.format(self._factor))

class B(A):
    def op2(self, factor):
        self._factor = factor
        print('Op2 with factor {}...'.format(self._factor))


obj = B(100)
obj.op1()    # Op1 with factor 100...
obj.op2(42)  # Op2 with factor 42...
obj.op1()    # Op1 with factor 42... &lt;- This is BAD</code></pre></div><p>In the preceding code, we have an attribute called <code class="literal">_factor</code>, and let's pretend it's so important that it isn't modified at runtime after the instance is created, because <code class="literal">op1</code> depends on it to function correctly. We've named it with a leading underscore, but the issue here is that when we call <code class="literal">obj.op2(42)</code>, we modify it, and this is reflected in subsequent calls to <code class="literal">op1</code>.</p><p>Let's fix this <span>undesired</span><a class="indexterm" id="id326332466"></a> behavior by adding <span>another</span><a class="indexterm" id="id326332474"></a> leading underscore:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="21"># oop/private.attrs.fixed.py
class A:
    def __init__(self, factor):
        self.__factor = factor

    def op1(self):
        print('Op1 with factor {}...'.format(self.__factor))

class B(A):
    def op2(self, factor):
        self.__factor = factor
        print('Op2 with factor {}...'.format(self.__factor))


obj = B(100)
obj.op1()    # Op1 with factor 100...
obj.op2(42)  # Op2 with factor 42...
obj.op1()    # Op1 with factor 100... &lt;- Wohoo! Now it's GOOD!</code></pre></div><p>Wow, look at that! Now it's working as desired. Python is kind of magic and in this case, what is happening is that the name-mangling mechanism has kicked in.</p><p>Name mangling means that any attribute name that has at least two leading underscores and at most one trailing underscore, such as <code class="literal">__my_attr</code>, is replaced with a name that includes an underscore and the class name before the actual name, such as <code class="literal">_ClassName__my_attr</code>.</p><p>This means that when you inherit from a class, the mangling mechanism gives your private attribute two different names in the base and child classes so that name collision is avoided. Every class and instance object stores references to their attributes in a special attribute called <code class="literal">__dict__</code>, so let's inspect <code class="literal">obj.__dict__</code> to see name mangling in action:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="22"># oop/private.attrs.py
print(obj.__dict__.keys())
# dict_keys(['_factor'])</code></pre></div><p>This is the <code class="literal">_factor</code> attribute that we find in the problematic version of this example. But look at the one that is using <code class="literal">__factor</code>:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="23"># oop/private.attrs.fixed.py
print(obj.__dict__.keys())
# dict_keys(['_A__factor', '_B__factor'])</code></pre></div><p>See? <code class="literal">obj</code> has two attributes now, <code class="literal">_A__factor</code> (mangled within the <code class="literal">A</code> class), and <code class="literal">_B__factor</code> (mangled within the <code class="literal">B</code> class). This is the mechanism that ensures that when you do <code class="literal">obj.__factor = 42</code>, <code class="literal">__factor</code> in <code class="literal">A</code> isn't changed, because you're actually touching <code class="literal">_B__factor</code>, which leaves <code class="literal">_A__factor</code> safe and sound.</p><p>If you're designing a <span>library</span><a class="indexterm" id="id326340651"></a> with classes that are meant to be <span>used</span><a class="indexterm" id="id326340660"></a> and extended by other developers, you will need to keep this in mind in order to avoid the unintentional overriding of your attributes. Bugs like these can be pretty subtle and hard to spot.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec86"></a>The property decorator</h3></div></div></div><p>Another thing that <span>would</span><a class="indexterm" id="id326340675"></a> be a crime not to <span>mention</span><a class="indexterm" id="id326340683"></a> is the <code class="literal">property</code> decorator. Imagine that you have an <code class="literal">age</code> attribute in a <code class="literal">Person</code> class and at some point you want to make sure that when you change its value, you're also checking that <code class="literal">age</code> is within a proper range, such as [18, 99]. You can write accessor methods, such as <code class="literal">get_age()</code> and <code class="literal">set_age(...)</code> (also called <span class="strong"><strong>getters</strong></span> and <span class="strong"><strong>setters</strong></span>), and put the logic there. <code class="literal">get_age()</code> will most likely just return <code class="literal">age</code>, while <code class="literal">set_age(...)</code> will also do the range check. The problem is that you may already have a lot of code accessing the <code class="literal">age</code> attribute directly, which means you're now up to some tedious refactoring. Languages like Java overcome this problem by using the accessor pattern <span>basically</span><a class="indexterm" id="id326341721"></a> by default. Many Java <span class="strong"><strong>Integrated Development Environments</strong></span> (<span class="strong"><strong>IDEs</strong></span>) autocomplete an attribute declaration by writing getter and setter accessor method stubs for you on the fly.</p><p>Python is smarter, and does this with the <code class="literal">property</code> decorator. When you decorate a method with <code class="literal">property</code>, you can use the name of the method as if it were a data attribute. Because of this, it's always best to refrain from putting logic that would take a while to complete in such methods because, by accessing them as attributes, we are not expecting to wait.</p><p>Let's look at an example:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="24"># oop/property.py
class Person:
    def __init__(self, age):
        self.age = age  # anyone can modify this freely

class PersonWithAccessors:
    def __init__(self, age):
        self._age = age

    def <span class="strong"><strong>get_age</strong></span>(self):
        return self._age

    def <span class="strong"><strong>set_age</strong></span>(self, age):
        if 18 &lt;= age &lt;= 99:
            self._age = age
        else:
            raise ValueError('Age must be within [18, 99]')

class PersonPythonic:
    def __init__(self, age):
        self._age = age

<span class="strong"><strong>@property</strong></span>
    def age(self):
        return self._age

<span class="strong"><strong>@age.setter</strong></span>
    def age(self, age):
        if 18 &lt;= age &lt;= 99:
            self._age = age
        else:
            raise ValueError('Age must be within [18, 99]')

person = PersonPythonic(39)
print(person.age)  # 39 - Notice we access as data attribute
person.age = 42    # Notice we access as data attribute
print(person.age)  # 42
person.age = 100   # ValueError: Age must be within [18, 99]</code></pre></div><p>The <code class="literal">Person</code> class may be the first version we write. Then we realize we need to put the range logic in place so, with another language, we would have to rewrite <code class="literal">Person</code> as the <code class="literal">PersonWithAccessors</code> class, and refactor all the code that was using <code class="literal">Person.age</code>. In Python, we rewrite <code class="literal">Person</code> as <code class="literal">PersonPythonic</code> (you normally wouldn't change the name, of course) so that the age is stored in a private <code class="literal">_age</code> variable, and we define property getters and setters using that decoration, which allows us to keep using the <code class="literal">person</code> instances as we were before. A getter is a method that is called when we access an attribute for reading. On the other hand, a setter is a method that is called when we access an attribute to write it. In other languages, such as Java, it's customary to define them as <code class="literal">get_age()</code> and <code class="literal">set_age(int value)</code>, but I find the Python syntax much neater. It allows you to start writing simple code and <span>refactor</span><a class="indexterm" id="id326345626"></a> later on, only when you need it, there is no <span>need</span><a class="indexterm" id="id326345635"></a> to pollute your code with accessors only because they may be helpful in the future.</p><p>The <code class="literal">property</code> decorator also allows for read-only data (no setter) and for special actions when the attribute is deleted. Please refer to the official documentation to dig deeper.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec87"></a>Operator overloading</h3></div></div></div><p>I find Python's approach to <span class="strong"><strong>operator overloading</strong></span> to be brilliant. To overload an operator means to give it a meaning <span>according</span><a class="indexterm" id="id326345657"></a> to the context in <span>which</span><a class="indexterm" id="id326346622"></a> it is used. For example, the <code class="literal">+</code> operator means addition when we deal with numbers, but concatenation when we deal with sequences.</p><p>In Python, when you use operators, you're most likely calling the special methods of some objects behind the scenes. For example, the <code class="literal">a[k]</code> call roughly translates to <code class="literal">type(a).__getitem__(a, k)</code>.</p><p>As an example, let's create a class that stores a string and evaluates to <code class="literal">True</code> if <code class="literal">'42'</code> is part of that string, and <code class="literal">False</code> otherwise. Also, let's give the class a length property that corresponds to that of the stored string:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="25"># oop/operator.overloading.py
class Weird:
    def __init__(self, s):
        self._s = s

    def __len__(self):
        return len(self._s)

    def __bool__(self):
        return '42' in self._s

weird = Weird('Hello! I am 9 years old!')
print(len(weird))  # 24
print(bool(weird))  # False

weird2 = Weird('Hello! I am 42 years old!')
print(len(weird2))  # 25
print(bool(weird2))  # True</code></pre></div><p>That was fun, wasn't it? For the complete list of magic methods that you can override in order to provide your custom implementation of operators for your classes, please refer to the Python data model in the official documentation.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec88"></a>Polymorphism – a brief overview</h3></div></div></div><p>The word <span class="strong"><strong>polymorphism</strong></span> comes <span>from</span><a class="indexterm" id="id326346669"></a> the Greek <span class="emphasis"><em>polys</em></span> (many, much) and <span class="emphasis"><em>morphē</em></span> (form, shape), and its meaning is the provision of a single interface for <span>entities</span><a class="indexterm" id="id326346754"></a> of different types.</p><p>In our car example, we call <code class="literal">engine.start()</code>, regardless of what kind of engine it is. As long as it exposes the start method, we can call it. That's polymorphism in action.</p><p>In other languages, such as Java, in order to give a function the ability to accept different types and call a method on them, those types need to be coded in such a way that they share an interface. In this way, the compiler knows that the method will be available regardless of the type of the object the function is fed (as long as it extends the proper interface, of course).</p><p>In Python, things are different. Polymorphism is implicit, nothing prevents you from calling a method on an object; therefore, technically, there is no need to implement interfaces or other patterns.</p><p>There is a special kind of polymorphism called <span class="strong"><strong>ad hoc polymorphism</strong></span>, which is what we saw in the last paragraph: operator overloading. This is the ability of an operator to change shape, according to the type of data it is fed.</p><p>Polymorphism also allows Python programmers to simply use the interface (methods and properties) exposed from an object rather than having to check which class it was instantiated from. This allows the code to be more compact and feel more natural.</p><p>I cannot spend too much time on polymorphism, but I encourage you to check it out by yourself, it will expand your understanding of OOP. Good luck!</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl2sec89"></a>Data classes</h3></div></div></div><p>Before we leave the OOP realm, there is one <span>last</span><a class="indexterm" id="id326346787"></a> thing I want to mention: data classes. Introduced in Python 3.7 by PEP557 (<a class="ulink" href="https://www.python.org/dev/peps/pep-0557/" target="_blank">https://www.python.org/dev/peps/pep-0557/</a>), they <span>can</span><a class="indexterm" id="id326346800"></a> be described as </p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>mutable named tuples with defaults</em></span></p></blockquote></div><p>. Let's dive into an example:</p><div class="informalexample"><pre class="programlisting language-markup"><code class=" language-markup" data-code-index="26"># oop/dataclass.py
from dataclasses import dataclass

@dataclass
class Body:
    '''Class to represent a physical body.'''
    name: str
    mass: float = 0.  # Kg
    speed: float = 1.  # m/s

    def kinetic_energy(self) -&gt; float:
        return (self.mass * self.speed ** 2) / 2


body = Body('Ball', 19, 3.1415)
print(body.kinetic_energy())  # 93.755711375 Joule
print(body)  # Body(name='Ball', mass=19, speed=3.1415)</code></pre></div><p>In the previous code, I have created a class to represent a physical body, with one method that allows me to calculate its kinetic energy (using the renowned formula <span class="emphasis"><em>E<sub>k</sub>=½mv<sup>2</sup></em></span>). Notice that <code class="literal">name</code> is supposed to be a string, while <code class="literal">mass</code> and <code class="literal">speed</code> are both floats, and both are given a default value. It's also interesting that I didn't have to write any <code class="literal">__init__</code> method, it's done for me by the <code class="literal">dataclass</code> decorator, along with methods for comparison and for producing the string representation of the object (implicitly called on the last line by <code class="literal">print</code>).</p><p>You can read all the specifications in PEP557 if you are curious, but for now just remember that data classes might offer a nicer, slightly more powerful alternative to named tuples, in case you need it.</p></div></div></div>
<div class="ng-hide" ng-show="!productController.entitled &amp;&amp; productController.isTruncatedContent">
<div class="fade-out" ng-show="productController.productType === 'book'">
</div>
</div>
<div class="ng-hide" ng-show="!productController.entitled &amp;&amp; productController.productType === 'video'">

</div>
</div>
<div class="video-wrapper ng-hide" ng-show="productController.productType === 'video' &amp;&amp; productController.entitled">

<div class="transcript panel panel-default ng-hide" id="transcript" ng-show="productController.hasCaptions"></div>
</div>


</div>






<div class="row ns">
<hr/>
</div>
</div>

</div>
</div>
</div>
</div>
</div>
</div>


<script src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/app.dfc913a7d3f9c785692c.bundle.js" type="text/javascript"></script>
<script id="" type="text/javascript">hj("tagRecording",[google_tag_manager["GTM-WJMM825"].macro(5)]);</script><iframe id="_hjRemoteVarsFrame" name="_hjRemoteVarsFrame" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/box-90f3a29ef7448451db5af955688970d7.html" style="display: none !important; width: 1px !important; height: 1px !important; opacity: 0 !important; pointer-events: none !important;" title="_hjRemoteVarsFrame"></iframe><div></div><script id="" type="text/javascript">window.heap=window.heap||[];
heap.load=function(e,d){window.heap.appid=e;window.heap.config=d=d||{};var a=d.forceSSL||"https:"===document.location.protocol,b=document.createElement("script");b.type="text/javascript";b.async=!0;b.src=(a?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(b,a);b=function(a){return function(){heap.push([a].concat(Array.prototype.slice.call(arguments,0)))}};a="addEventProperties addUserProperties clearEventProperties identify removeEventProperty setEventProperties track unsetEventProperty".split(" ");for(var c=
0;c<a.length;c++)heap[a[c]]=b(a[c])};window.heap.appid||heap.load("34805961");</script><script id="" type="text/javascript">var HeapUserId="undefined";"string"===typeof HeapUserId&&"undefined"!==HeapUserId&&window.heap.identify(HeapUserId);</script>
<script id="" type="text/javascript">!function(b,e,f,g,a,c,d){b.fbq||(a=b.fbq=function(){a.callMethod?a.callMethod.apply(a,arguments):a.queue.push(arguments)},b._fbq||(b._fbq=a),a.push=a,a.loaded=!0,a.version="2.0",a.queue=[],c=e.createElement(f),c.async=!0,c.src=g,d=e.getElementsByTagName(f)[0],d.parentNode.insertBefore(c,d))}(window,document,"script","//connect.facebook.net/en_US/fbevents.js");fbq("init","445429252334850");fbq("track","PageView");</script>

<script id="" type="text/javascript">window.dataLayer=window.dataLayer||[];window.dataLayer.push({pageLoaded:"pageLoaded"});</script><script id="" type="text/javascript">(function(a,e,f,g,b,c,d){a.ProfitWellObject=b;a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)};a[b].l=1*new Date;c=e.createElement(f);d=e.getElementsByTagName(f)[0];c.async=1;c.src=g;d.parentNode.insertBefore(c,d)})(window,document,"script","https://dna8twue3dlxq.cloudfront.net/js/profitwell.js","profitwell");profitwell("auth_token","8c79afc46264fdacbbb5c7bfc3b4800f");profitwell("user_email","");</script><iframe aria-hidden="true" id="intercom-frame" src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/saved_resource.html" style="position: absolute !important; opacity: 0 !important; width: 1px !important; height: 1px !important; top: 0 !important; left: 0 !important; border: none !important; display: block !important; z-index: -1 !important;" tabindex="-1"></iframe><script src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/adsct" type="text/javascript"></script><div id="intercom-css-container"><style data-emotion="intercom-global"></style><style data-emotion="intercom"></style></div><script id="" type="text/javascript">window.heap=window.heap||[];
heap.load=function(e,d){window.heap.appid=e;window.heap.config=d=d||{};var a=d.forceSSL||"https:"===document.location.protocol,b=document.createElement("script");b.type="text/javascript";b.async=!0;b.src=(a?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(b,a);b=function(a){return function(){heap.push([a].concat(Array.prototype.slice.call(arguments,0)))}};a="addEventProperties addUserProperties clearEventProperties identify removeEventProperty setEventProperties track unsetEventProperty".split(" ");for(var c=
0;c<a.length;c++)heap[a[c]]=b(a[c])};window.heap.appid||heap.load("34805961");</script><script id="" type="text/javascript">var HeapUserId="72f2212e-37fa-4f9e-80a7-7aeb3cbd99b3";"string"===typeof HeapUserId&&"undefined"!==HeapUserId&&window.heap.identify(HeapUserId);</script>
<script id="" type="text/javascript">!function(b,e,f,g,a,c,d){b.fbq||(a=b.fbq=function(){a.callMethod?a.callMethod.apply(a,arguments):a.queue.push(arguments)},b._fbq||(b._fbq=a),a.push=a,a.loaded=!0,a.version="2.0",a.queue=[],c=e.createElement(f),c.async=!0,c.src=g,d=e.getElementsByTagName(f)[0],d.parentNode.insertBefore(c,d))}(window,document,"script","//connect.facebook.net/en_US/fbevents.js");fbq("init","445429252334850");fbq("track","PageView");</script>

<script id="" type="text/javascript">(function(c,d,e,f,g,a,b){c[e]=c[e]||[];a=d.createElement(f);a.async=1;a.src=g;b=d.getElementsByTagName(f)[0];b.parentNode.insertBefore(a,b)})(window,document,"_gscq","script","//widgets.getsitecontrol.com/95715/script.js");</script><script src="./9781788996662_6_ch06lvl1sec63_object-oriented-programming-oop_files/adsct" type="text/javascript"></script></body></html>